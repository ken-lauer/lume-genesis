#!/usr/bin/env python
# vi: syntax=python sw=4 ts=4 sts=4
"""
This file is auto-generated by lume-genesis (`genesis.version4.input.manual`).

Do not hand-edit it.
"""

from __future__ import annotations
from typing import Literal, Union

import pydantic

from .. import types


class Setup(types.NameList):
    r"""
    The namelist `setup` is a mandatory namelist and should be the first in the
    input deck. It contains the basic parameters to control the simulations. It can
    only be called once. If the user want to change some parameter the namelist
    `alter_setup` should be used.

    Setup corresponds to Genesis 4 `setup`.

    Attributes
    ----------
    rootname : str, default=""
        The basic string, with which all output files will start, unless the output
        filename is directly overwritten (see `write` namelist)
    outputdir : str, default=""
        Output directory name.
    lattice : str, default=""
        The name of the file which contains the undulator lattice description. This can
        also include some relative paths if the lattice file is not in the same
        directory as the input file.
    beamline : str, default=""
        The name of the beamline, which has to be defined within the lattice file. For
        more information on the lattice file, see the next chapter.
    gamma0 : float, default=11350.3
        The reference energy in unites of the electron rest mass. This is the reference
        energy which is used in the code at various place, mostly in the calculation of
        the matching condition, the reference focusing strength of quadrupoles and
        undulator as well as the default value if an electron distribution is
        generated.
    lambda0 : float, default=1e-10
        The reference wavelength in meter, which is used as the wavelength in steady-
        state simulation or for defining the sample distance in time-dependent runs. It
        also acts as the default value when field distributions are generated.
    delz : float, default=0.015
        Preferred integration stepsize in meter. Note that this is not a strict value
        because Genesis tries to optimized the stepsize according to the elements it
        can resolve. E.g. if an undulator is 1.99 m long but the preferred stepsize is
        2 cm than it uses a stepsize which is the closest to preserve the number of
        integration step. In this case the preferred stepsize gives 99.5 steps which is
        than rounded to 100 and thus resulting in an actual stepsize of 1.99 cm. Note
        that outside of the undulator, which are free drifts for the radiation field,
        Genesis progresses the electron beam and radiation field in larger steps,
        namely one step per resolved element (drift, quadrupole, phase shifter).
    seed : int, default=123456789
        Seed to initialize the random number generator, which is used for shot noise
        calculation and undulator lattice errors, though it is recommended that the
        random number generator seed is redefined explicitly for undulator errors in
        its corresponding namelist.
    npart : int, default=8192
        Number of macro particles per slice. Note that the number must be a multiple of
        the used bins `nbins` otherwise Genesis will exit with an error. If one-for-one
        simulations are used, this parameter has no meaning.
    nbins : int, default=4
        Number of macro particles, which are grouped into beamlets for gener ating the
        correct shot noise. For one-for-one simulations this parameter has no meaning
    one4one : bool, default=False
        Flag to enable or disable resolving each electron in the simulation. This is
        mandatory for certain features, such as sorting or slicing of particle
        distributions. If set to `true` other parameters such as `npart` and `nbins`
        are obsolete and do not need to be defined. It is recommended to estimate the
        number of electrons, which are generated in the simulations, because this can
        easily required memory beyond what is available on the computer.
    shotnoise : bool, default=True
        Flag to enable the calculation of shotnoise per each slice during generation of
        the electron distribution. It is recommended to set the value to `false` for
        steady-state or scan simulations.
    beam_global_stat : bool, default=False
        Flag to enable extra output of beam parameters of the entire bunch, such as
        energy, energy spread etc. The data are placed in the HDF group ”Global” within
        the group ”Beam” of the output file
    field_global_stat : bool, default=False
        Flag for the field output, similar to `beam_global_stat`.
    exclude_spatial_output : bool, default=False
        Flag to suppress the datasets in the output file for the x- and y-position and
        size (both Beam and Field) and px- and py-position (Beam only). This might be
        useful to reduce the file size of the output file, if these datasets are not
        needed for the post-processing
    exclude_fft_output : bool, default=False
        Flag to suppress the datasets in the output file for the field divergence and
        pointing. Since it also disable the FFT calculation of the 2D wavefronts it
        speeds up the execution time slightly. If the code has been compiled without
        the support of the FFTW library this parametr has no effect.
    exclude_intensity_output : bool, default=False
        Flag to suppress the datasets for the near and farfield intensity and phase for
        the radiation field. If excluded the output file size becomes smaller but no
        post-processing calculation of the spectra is possible.
    exclude_energy_output : bool, default=False
        Flag to suppress the datasets in the output file for the mean energy and energy
        spread of the electron beam.
    exclude_aux_output : bool, default=False
        Flag to suppress the auxiliary datasets in the output file. In the moment it is
        the long-range longitudinal electric field as seen by the electrons.
    exclude_current_output : bool, default=True
        Flag to reduce the size of the current dataset for the electron beam. Under
        most circumstances the current profile is constant and only the initial current
        profile is written out. However, simulation with one-4-one set to `true` and
        sorting events the current profile might change. Example are ESASE/HGHG
        schemes. By setting the flag to false the current profile is written out at
        each output step similar to radiation power and bunching profile.
    exclude_field_dump : bool, default=False
        Exclude the field dump to `.fld.h5`.
    write_meta_file : bool, default=False
        Write a metadata file.
    semaphore_file_name : str, default=""
        Providing a file name for the semaphore file always switches on writing the
        "done" semaphore file, overriding 'write_semaphore_file' flag. This allows to
        switch on semaphore functionality just by specifying corresponding command line
        argument -- no modification of G4 input file needed.
    write_semaphore_file : bool, default=False
        Write a semaphore file when the simulation has completed.
    write_semaphore_file_done : bool, default=False
        Alias for `write_semaphore_file`. This takes precedence over
        `write_semaphore_file` if both are specified.
    write_semaphore_file_started : bool, default=False
        Write a semaphore file at startup, after the setup block is parsed.
    """

    type: Literal["setup"] = "setup"
    rootname: str = pydantic.Field(
        default="",
        description=r"""
        The basic string, with which all output files will start, unless the
        output filename is directly overwritten (see `write` namelist)
        """.strip(),
    )
    outputdir: str = pydantic.Field(
        default="",
        description=r"Output directory name.",
    )
    lattice: str = pydantic.Field(
        default="",
        description=r"""
        The name of the file which contains the undulator lattice description.
        This can also include some relative paths if the lattice file is not in
        the same directory as the input file.
        """.strip(),
    )
    beamline: str = pydantic.Field(
        default="",
        description=r"""
        The name of the beamline, which has to be defined within the lattice file.
        For more information on the lattice file, see the next chapter.
        """.strip(),
    )
    gamma0: float = pydantic.Field(
        default=11350.3,
        description=r"""
        The reference energy in unites of the electron rest mass. This is the
        reference energy which is used in the code at various place, mostly in the
        calculation of the matching condition, the reference focusing strength of
        quadrupoles and undulator as well as the default value if an electron
        distribution is generated.
        """.strip(),
    )
    lambda0: float = pydantic.Field(
        default=1e-10,
        description=r"""
        The reference wavelength in meter, which is used as the wavelength in
        steady-state simulation or for defining the sample distance in time-
        dependent runs. It also acts as the default value when field distributions
        are generated.
        """.strip(),
    )
    delz: float = pydantic.Field(
        default=0.015,
        description=r"""
        Preferred integration stepsize in meter. Note that this is not a strict
        value because Genesis tries to optimized the stepsize according to the
        elements it can resolve. E.g. if an undulator is 1.99 m long but the
        preferred stepsize is 2 cm than it uses a stepsize which is the closest to
        preserve the number of integration step. In this case the preferred
        stepsize gives 99.5 steps which is than rounded to 100 and thus resulting
        in an actual stepsize of 1.99 cm. Note that outside of the undulator,
        which are free drifts for the radiation field, Genesis progresses the
        electron beam and radiation field in larger steps, namely one step per
        resolved element (drift, quadrupole, phase shifter).
        """.strip(),
    )
    seed: int = pydantic.Field(
        default=123456789,
        description=r"""
        Seed to initialize the random number generator, which is used for shot
        noise calculation and undulator lattice errors, though it is recommended
        that the random number generator seed is redefined explicitly for
        undulator errors in its corresponding namelist.
        """.strip(),
    )
    npart: int = pydantic.Field(
        default=8192,
        description=r"""
        Number of macro particles per slice. Note that the number must be a
        multiple of the used bins `nbins` otherwise Genesis will exit with an
        error. If one-for-one simulations are used, this parameter has no meaning.
        """.strip(),
    )
    nbins: int = pydantic.Field(
        default=4,
        description=r"""
        Number of macro particles, which are grouped into beamlets for gener ating
        the correct shot noise. For one-for-one simulations this parameter has no
        meaning
        """.strip(),
    )
    one4one: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to enable or disable resolving each electron in the simulation. This
        is mandatory for certain features, such as sorting or slicing of particle
        distributions. If set to `true` other parameters such as `npart` and
        `nbins` are obsolete and do not need to be defined. It is recommended to
        estimate the number of electrons, which are generated in the simulations,
        because this can easily required memory beyond what is available on the
        computer.
        """.strip(),
    )
    shotnoise: bool = pydantic.Field(
        default=True,
        description=r"""
        Flag to enable the calculation of shotnoise per each slice during
        generation of the electron distribution. It is recommended to set the
        value to `false` for steady-state or scan simulations.
        """.strip(),
    )
    beam_global_stat: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to enable extra output of beam parameters of the entire bunch, such
        as energy, energy spread etc. The data are placed in the HDF group
        ”Global” within the group ”Beam” of the output file
        """.strip(),
    )
    field_global_stat: bool = pydantic.Field(
        default=False,
        description=r"Flag for the field output, similar to `beam_global_stat`.",
    )
    exclude_spatial_output: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to suppress the datasets in the output file for the x- and y-position
        and size (both Beam and Field) and px- and py-position (Beam only). This
        might be useful to reduce the file size of the output file, if these
        datasets are not needed for the post-processing
        """.strip(),
    )
    exclude_fft_output: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to suppress the datasets in the output file for the field divergence
        and pointing. Since it also disable the FFT calculation of the 2D
        wavefronts it speeds up the execution time slightly. If the code has been
        compiled without the support of the FFTW library this parametr has no
        effect.
        """.strip(),
    )
    exclude_intensity_output: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to suppress the datasets for the near and farfield intensity and
        phase for the radiation field. If excluded the output file size becomes
        smaller but no post-processing calculation of the spectra is possible.
        """.strip(),
    )
    exclude_energy_output: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to suppress the datasets in the output file for the mean energy and
        energy spread of the electron beam.
        """.strip(),
    )
    exclude_aux_output: bool = pydantic.Field(
        default=False,
        description=r"""
        Flag to suppress the auxiliary datasets in the output file. In the moment
        it is the long-range longitudinal electric field as seen by the electrons.
        """.strip(),
    )
    exclude_current_output: bool = pydantic.Field(
        default=True,
        description=r"""
        Flag to reduce the size of the current dataset for the electron beam.
        Under most circumstances the current profile is constant and only the
        initial current profile is written out. However, simulation with one-4-one
        set to `true` and sorting events the current profile might change. Example
        are ESASE/HGHG schemes. By setting the flag to false the current profile
        is written out at each output step similar to radiation power and bunching
        profile.
        """.strip(),
    )
    exclude_field_dump: bool = pydantic.Field(
        default=False,
        description=r"Exclude the field dump to `.fld.h5`.",
    )
    write_meta_file: bool = pydantic.Field(
        default=False,
        description=r"Write a metadata file.",
    )
    semaphore_file_name: str = pydantic.Field(
        default="",
        description=r"""
        Providing a file name for the semaphore file always switches on writing
        the "done" semaphore file, overriding 'write_semaphore_file' flag. This
        allows to switch on semaphore functionality just by specifying
        corresponding command line argument -- no modification of G4 input file
        needed.
        """.strip(),
    )
    write_semaphore_file: bool = pydantic.Field(
        default=False,
        description=r"Write a semaphore file when the simulation has completed.",
    )
    write_semaphore_file_done: bool = pydantic.Field(
        default=False,
        description=r"""
        Alias for `write_semaphore_file`. This takes precedence over
        `write_semaphore_file` if both are specified.
        """.strip(),
    )
    write_semaphore_file_started: bool = pydantic.Field(
        default=False,
        description=r"Write a semaphore file at startup, after the setup block is parsed.",
    )


class AlterSetup(types.NameList):
    r"""
    A namelist to change some parameters within the simulation, which have been
    defined alread by the `setup`-namelist. The change values are stored in the
    setup module so that for another invocation of alter_setup some defaults values
    are use which have been defined in the preceding call of alter_setup

    AlterSetup corresponds to Genesis 4 `alter_setup`.

    Attributes
    ----------
    rootname : str, default=""
        The basic string, with which all output files will start, unless the output
        filename is directly overwritten (see `write`-namelist)
    beamline : str, default=""
        The name of the beamline, which has to be defined within the lattice file. This
        way another beamline can be selected in the case the simulation has multiple
        stages
    delz : float, default=0.0
        Preferred integration stepsize in meter. Note that this is not a strict value
        because Genesis tries to optimized the stepsize according to the elements it
        can resolve. E.g. if an undulator is 1.99 m long but the preferred stepsize is
        2 cm than it uses a stepsize which is the closes to preserve the number of
        integration step. In this case the preferred stepsize gives 99.5 steps which is
        than rounded to 100 and thus resulting in an actual stepsize of 1.99 cm. Note
        that outside of the undulator Genesis, which are free drifts for the radiation
        field, it progress the electron beam and radiation field in larger steps,
        namely one step per resolved element (drift, quadrupole, phase shifter).
    harmonic : int, default=1
        If the value is not 1 than a harmonic conversion is done. This has several
        consequences. The reference wavelength in `setup` is divided by the harmonic
        number, the sample rate in `time` is multiplied by the harmonic number, the
        ponderomotive phases of all macro particles are scaled with the harmonic
        number, all radiation fields, which are not identical to the harmonic numbers
        are deleted, while an existing harmonic field is changed to be at the
        fundamental wavelength
    subharmonic : int, default=1
        If the value is not 1 than a down conversion is done. It is similar to the
        action of `harmonics` but in the opposite directions. For the radiation field
        all field definitions are deleted except for the fundamental, which is
        converted to a harmonic. In this case the fundamental field needs to be defined
        before another tracking is called.
    resample : bool, default=False
        If this is set to true and only if one-for-one simulations are used the
        harmonic and subharmonic conversion can re-sample to the new wavelength. In the
        case of up-conversion the slices are split and the total number of slices
        increases. Same with the radiation field. An previously existing harmonic
        field, which is now becoming the fundamental, is interpolated between the
        existing sample points (still needs to be implemented). If a new field is
        generated it has automatically the new number of slices. If also prevents that
        the sample rate is changed by remaining unchanged.
    disable : bool, default=False
        Disable non-matching radiation harmonic.
    """

    type: Literal["alter_setup"] = "alter_setup"
    rootname: str = pydantic.Field(
        default="",
        description=r"""
        The basic string, with which all output files will start, unless the
        output filename is directly overwritten (see `write`-namelist)
        """.strip(),
    )
    beamline: str = pydantic.Field(
        default="",
        description=r"""
        The name of the beamline, which has to be defined within the lattice file.
        This way another beamline can be selected in the case the simulation has
        multiple stages
        """.strip(),
    )
    delz: float = pydantic.Field(
        default=0.0,
        description=r"""
        Preferred integration stepsize in meter. Note that this is not a strict
        value because Genesis tries to optimized the stepsize according to the
        elements it can resolve. E.g. if an undulator is 1.99 m long but the
        preferred stepsize is 2 cm than it uses a stepsize which is the closes to
        preserve the number of integration step. In this case the preferred
        stepsize gives 99.5 steps which is than rounded to 100 and thus resulting
        in an actual stepsize of 1.99 cm. Note that outside of the undulator
        Genesis, which are free drifts for the radiation field, it progress the
        electron beam and radiation field in larger steps, namely one step per
        resolved element (drift, quadrupole, phase shifter).
        """.strip(),
    )
    harmonic: int = pydantic.Field(
        default=1,
        description=r"""
        If the value is not 1 than a harmonic conversion is done. This has several
        consequences. The reference wavelength in `setup` is divided by the
        harmonic number, the sample rate in `time` is multiplied by the harmonic
        number, the ponderomotive phases of all macro particles are scaled with
        the harmonic number, all radiation fields, which are not identical to the
        harmonic numbers are deleted, while an existing harmonic field is changed
        to be at the fundamental wavelength
        """.strip(),
    )
    subharmonic: int = pydantic.Field(
        default=1,
        description=r"""
        If the value is not 1 than a down conversion is done. It is similar to the
        action of `harmonics` but in the opposite directions. For the radiation
        field all field definitions are deleted except for the fundamental, which
        is converted to a harmonic. In this case the fundamental field needs to be
        defined before another tracking is called.
        """.strip(),
    )
    resample: bool = pydantic.Field(
        default=False,
        description=r"""
        If this is set to true and only if one-for-one simulations are used the
        harmonic and subharmonic conversion can re-sample to the new wavelength.
        In the case of up-conversion the slices are split and the total number of
        slices increases. Same with the radiation field. An previously existing
        harmonic field, which is now becoming the fundamental, is interpolated
        between the existing sample points (still needs to be implemented). If a
        new field is generated it has automatically the new number of slices. If
        also prevents that the sample rate is changed by remaining unchanged.
        """.strip(),
    )
    disable: bool = pydantic.Field(
        default=False,
        description=r"Disable non-matching radiation harmonic.",
    )


class Lattice(types.NameList):
    r"""
    This namelist is used to change the raw lattice from the lattice file, such as
    generating errors in the position of the elements. The namelist can be defined
    several times to add more than one error source to the lattice.

    Lattice corresponds to Genesis 4 `lattice`.

    Attributes
    ----------
    zmatch : float, default=0.0
        If the position within the undulator in meter is non-zero than Genesis tries to
        calculate the matched optics function for a periodic solution. In the case that
        it cannot find a solution than it will report it. Found solution will also be
        the default values for a succeeding beam generation, so that no explicit
        optical functions need to be defined any longer. If the lattice is highly non-
        periodic it is recommended    to find the matching condition with an external
        program such as MAdX.
    element : str, default=""
        Name of the element type, which will be changed, e.g. Undulator if undulator
        modules are altered. Only the first 4 letters need to be defined. If there is
        no match, e.g. due to a type, nothing will be changed. It acts rather as a
        filter than a mandatory element. Elements of the type `MARKER` are not
        supported.
    field : str, default=""
        attribute name for a given element. The names are the same as in the definition
        of the lattice file. The field acts as a filter again. With non-matching events
        nothing will be changed.
    value : float, default=0.0
        The new value. If a reference to a sequence is used, values can be different
        depending on how many elements are changed. For a double the value would be the
        same for all elements affected.
    instance : int, default=0
        The instances of affected elements. If a positive value is given, than only
        that element is changed, where its occurence matches the number. E.g. for a
        value of 3 only the third element is selected. For a value of 0 all elements
        are changed. The ability to change more than one but less than all is currently
        not supported.
    add : bool, default=True
        If the value is `true`, the changes are added to the existing value. For a
        value of `false`, the old values are overwritten.
    resolvePeriod : bool, default=False
        currently unused.
    """

    type: Literal["lattice"] = "lattice"
    zmatch: float = pydantic.Field(
        default=0.0,
        description=r"""
        If the position within the undulator in meter is non-zero than Genesis
        tries to calculate the matched optics function for a periodic solution. In
        the case that it cannot find a solution than it will report it. Found
        solution will also be the default values for a succeeding beam generation,
        so that no explicit optical functions need to be defined any longer. If
        the lattice is highly non-periodic it is recommended    to find the
        matching condition with an external program such as MAdX.
        """.strip(),
    )
    element: str = pydantic.Field(
        default="",
        description=r"""
        Name of the element type, which will be changed, e.g. Undulator if
        undulator modules are altered. Only the first 4 letters need to be
        defined. If there is no match, e.g. due to a type, nothing will be
        changed. It acts rather as a filter than a mandatory element. Elements of
        the type `MARKER` are not supported.
        """.strip(),
    )
    field: str = pydantic.Field(
        default="",
        description=r"""
        attribute name for a given element. The names are the same as in the
        definition of the lattice file. The field acts as a filter again. With
        non-matching events nothing will be changed.
        """.strip(),
    )
    value: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        The new value. If a reference to a sequence is used, values can be
        different depending on how many elements are changed. For a double the
        value would be the same for all elements affected.
        """.strip(),
    )
    instance: int = pydantic.Field(
        default=0,
        description=r"""
        The instances of affected elements. If a positive value is given, than
        only that element is changed, where its occurence matches the number. E.g.
        for a value of 3 only the third element is selected. For a value of 0 all
        elements are changed. The ability to change more than one but less than
        all is currently not supported.
        """.strip(),
    )
    add: bool = pydantic.Field(
        default=True,
        description=r"""
        If the value is `true`, the changes are added to the existing value. For a
        value of `false`, the old values are overwritten.
        """.strip(),
    )
    resolvePeriod: bool = pydantic.Field(
        default=False,
        description=r"currently unused.",
    )


class Time(types.NameList):
    r"""
    This namelist defines the time window/range for simulation with more than just
    one slice.
    For reference the complementary axis of the undulator axis, which is normally
    the position in the time frame, is expressed in a position `s`. Normally
    everything is aligned to the origins = 0, in particular when external
    distributions are imported. Note that for parallel execution the number of
    slices per core must be the same for an efficient writing of the output files.
    Therefore Genesis extends the time-window to symmetrize the number of slices
    per core by extending it towards larger values of `s`.
    As an example, with `XLAMDS=1e-6` and a length `SLEN=20e-6` a call of Genesis
    with 24 cores would generate a time-window of 24 microns because each core
    would have one slice, while 15 cores would expand it to 30 microns with 2
    slices per core each.

    This module defines also scans in either field or beam parameters if the
    corresponding flag is set. Technically it generates the beam and field as for
    time-dependence but disables slippage during simulations. That way the
    radiation field is kept in the same slice, acting as steady-state simulations.

    Time corresponds to Genesis 4 `time`.

    Attributes
    ----------
    s0 : float, default=0.0
        Starting point of the time-window in meters.
    slen : float, default=0.0
        Length of the time window in meters. Note that for parallel jobs this might be
        adjusted towards larger values.
    sample : int, default=1
        Sample rate in units of the reference wavelength from thesetup namelist, so
        that the number of slices is given by `SLEN / LAMBDA0 /SAMPLE` after `SLEN` has
        been adjusted to fit the MPI size.
    time : bool, default=True
        Flag to indicate time-dependent run. Note that time-dependent simulations are
        enabled already by using this namelist. This flag has the functionality to
        differentiate between time-dependent run and scans, which disable the slippage
        in the tracking. To restrict the simulation to steady-state the `time` namelist
        has to be omitted from the input deck.
    """

    type: Literal["time"] = "time"
    s0: float = pydantic.Field(
        default=0.0,
        description=r"Starting point of the time-window in meters.",
    )
    slen: float = pydantic.Field(
        default=0.0,
        description=r"""
        Length of the time window in meters. Note that for parallel jobs this
        might be adjusted towards larger values.
        """.strip(),
    )
    sample: int = pydantic.Field(
        default=1,
        description=r"""
        Sample rate in units of the reference wavelength from thesetup namelist,
        so that the number of slices is given by `SLEN / LAMBDA0 /SAMPLE` after
        `SLEN` has been adjusted to fit the MPI size.
        """.strip(),
    )
    time: bool = pydantic.Field(
        default=True,
        description=r"""
        Flag to indicate time-dependent run. Note that time-dependent simulations
        are enabled already by using this namelist. This flag has the
        functionality to differentiate between time-dependent run and scans, which
        disable the slippage in the tracking. To restrict the simulation to
        steady-state the `time` namelist has to be omitted from the input deck.
        """.strip(),
    )


class ProfileConst(types.NameList):
    r"""

    ProfileConst corresponds to Genesis 4 `profile_const`.

    Attributes
    ----------
    label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    c0 : float, default=0.0
        constant value to be used.
    """

    type: Literal["profile_const"] = "profile_const"
    label: str = pydantic.Field(
        description=r"Name of the profile, which is used to refer to it in later calls of namelists",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"constant value to be used.",
    )


class ProfileGauss(types.NameList):
    r"""

    ProfileGauss corresponds to Genesis 4 `profile_gauss`.

    Attributes
    ----------
    label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    c0 : float, default=0.0
        Maximum function value of the Gaussian distribution
    s0 : float, default=0.0
        Center point of the Gaussian distribution
    sig : float, default=0.0
        Standard deviation of the Gaussian distribution
    """

    type: Literal["profile_gauss"] = "profile_gauss"
    label: str = pydantic.Field(
        description=r"Name of the profile, which is used to refer to it in later calls of namelists",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"Maximum function value of the Gaussian distribution",
    )
    s0: float = pydantic.Field(
        default=0.0,
        description=r"Center point of the Gaussian distribution",
    )
    sig: float = pydantic.Field(
        default=0.0,
        description=r"Standard deviation of the Gaussian distribution",
    )


class ProfileStep(types.NameList):
    r"""

    ProfileStep corresponds to Genesis 4 `profile_step`.

    Attributes
    ----------
    label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    c0 : float, default=0.0
        Constant term
    s_start : float, default=0.0
        Starting point of the step function
    s_end : float, default=0.0
        Ending point of the step function
    """

    type: Literal["profile_step"] = "profile_step"
    label: str = pydantic.Field(
        description=r"Name of the profile, which is used to refer to it in later calls of namelists",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"Constant term",
    )
    s_start: float = pydantic.Field(
        default=0.0,
        description=r"Starting point of the step function",
    )
    s_end: float = pydantic.Field(
        default=0.0,
        description=r"Ending point of the step function",
    )


class ProfilePolynom(types.NameList):
    r"""

    ProfilePolynom corresponds to Genesis 4 `profile_polynom`.

    Attributes
    ----------
    label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    c0 : float, default=0.0
        Constant term
    c1 : float, default=0.0
        Term proportional to s
    c2 : float, default=0.0
        Term proportional to s^2
    c3 : float, default=0.0
        Term proportional to s^3
    c4 : float, default=0.0
        Term proportional to s^4
    """

    type: Literal["profile_polynom"] = "profile_polynom"
    label: str = pydantic.Field(
        description=r"Name of the profile, which is used to refer to it in later calls of namelists",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"Constant term",
    )
    c1: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s",
    )
    c2: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s^2",
    )
    c3: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s^3",
    )
    c4: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s^4",
    )


class ProfileFile(types.NameList):
    r"""

    ProfileFile corresponds to Genesis 4 `profile_file`.

    Attributes
    ----------
    label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    xdata : str, default=""
        Points to a dataset in an HDF5 file to define the `s`-position for the look-up
        table. The format is `filename/group1/.../groupn/datasetname`, where the naming
        of groups is not required if the dataset is at root level of the HDF file
    ydata : str, default=""
        Same as y data but for the function values of the look-up table.
    isTime : bool, default=False
        If true the `s`-position is a time variable and therefore multiplied with the
        speed of light `c` to get the position in meters.
    reverse : bool, default=False
        if true the order in the look-up table is reverse. This is sometimes needed
        because time and spatial coordinates differ sometimes by a minus sign.
    autoassign : bool, default=False
        use the HDF5 file from `xdata` (TODO more details).
    """

    type: Literal["profile_file"] = "profile_file"
    label: str = pydantic.Field(
        description=r"Name of the profile, which is used to refer to it in later calls of namelists",
    )
    xdata: str = pydantic.Field(
        default="",
        description=r"""
        Points to a dataset in an HDF5 file to define the `s`-position for the
        look-up table. The format is `filename/group1/.../groupn/datasetname`,
        where the naming of groups is not required if the dataset is at root level
        of the HDF file
        """.strip(),
    )
    ydata: str = pydantic.Field(
        default="",
        description=r"Same as y data but for the function values of the look-up table.",
    )
    isTime: bool = pydantic.Field(
        default=False,
        description=r"""
        If true the `s`-position is a time variable and therefore multiplied with
        the speed of light `c` to get the position in meters.
        """.strip(),
    )
    reverse: bool = pydantic.Field(
        default=False,
        description=r"""
        if true the order in the look-up table is reverse. This is sometimes
        needed because time and spatial coordinates differ sometimes by a minus
        sign.
        """.strip(),
    )
    autoassign: bool = pydantic.Field(
        default=False,
        description=r"use the HDF5 file from `xdata` (TODO more details).",
    )


class SequenceConst(types.NameList):
    r"""

    SequenceConst corresponds to Genesis 4 `sequence_const`.

    Attributes
    ----------
    label : str
        Name of the sequence, which is used to refer to it in the lattice
    c0 : float, default=0.0
        constant value to be used.
    """

    type: Literal["sequence_const"] = "sequence_const"
    label: str = pydantic.Field(
        description=r"Name of the sequence, which is used to refer to it in the lattice",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"constant value to be used.",
    )


class SequencePolynom(types.NameList):
    r"""

    SequencePolynom corresponds to Genesis 4 `sequence_polynom`.

    Attributes
    ----------
    label : str
        Name of the sequence, which is used to refer to it in the lattice
    c0 : float, default=0.0
        Constant term
    c1 : float, default=0.0
        Term proportional to s
    c2 : float, default=0.0
        Term proportional to s^2
    c3 : float, default=0.0
        Term proportional to s^3
    c4 : float, default=0.0
        Term proportional to s^4
    """

    type: Literal["sequence_polynom"] = "sequence_polynom"
    label: str = pydantic.Field(
        description=r"Name of the sequence, which is used to refer to it in the lattice",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"Constant term",
    )
    c1: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s",
    )
    c2: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s^2",
    )
    c3: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s^3",
    )
    c4: float = pydantic.Field(
        default=0.0,
        description=r"Term proportional to s^4",
    )


class SequencePower(types.NameList):
    r"""

    SequencePower corresponds to Genesis 4 `sequence_power`.

    Attributes
    ----------
    label : str
        Name of the sequence, which is used to refer to it in the lattice
    c0 : float, default=0.0
        Constant term
    dc : float, default=0.0
        Term scaling the growing power series before added to the constant term
    alpha : float, default=0.0
        power of the series
    n0 : int, default=1
        starting index of power growth. Otherwise the sequence uses only the constant
        term
    """

    type: Literal["sequence_power"] = "sequence_power"
    label: str = pydantic.Field(
        description=r"Name of the sequence, which is used to refer to it in the lattice",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"Constant term",
    )
    dc: float = pydantic.Field(
        default=0.0,
        description=r"Term scaling the growing power series before added to the constant term",
    )
    alpha: float = pydantic.Field(
        default=0.0,
        description=r"power of the series",
    )
    n0: int = pydantic.Field(
        default=1,
        description=r"""
        starting index of power growth. Otherwise the sequence uses only the
        constant term
        """.strip(),
    )


class SequenceRandom(types.NameList):
    r"""

    SequenceRandom corresponds to Genesis 4 `sequence_random`.

    Attributes
    ----------
    label : str
        Name of the sequence, which is used to refer to it in the lattice
    c0 : float, default=0.0
        Mean value
    dc : float, default=0.0
        Amplitude of the error, either the standard division for normal distribution or
        the min and max value for uniform distribution.
    seed : int, default=100
        seed for the random number generator
    normal : bool, default=True
        Flag for Gaussian distribution. If set to false a uniform distribution is used.
    """

    type: Literal["sequence_random"] = "sequence_random"
    label: str = pydantic.Field(
        description=r"Name of the sequence, which is used to refer to it in the lattice",
    )
    c0: float = pydantic.Field(
        default=0.0,
        description=r"Mean value",
    )
    dc: float = pydantic.Field(
        default=0.0,
        description=r"""
        Amplitude of the error, either the standard division for normal
        distribution or the min and max value for uniform distribution.
        """.strip(),
    )
    seed: int = pydantic.Field(
        default=100,
        description=r"seed for the random number generator",
    )
    normal: bool = pydantic.Field(
        default=True,
        description=r"Flag for Gaussian distribution. If set to false a uniform distribution is used.",
    )


class Beam(types.NameList):
    r"""
    This namelist initiates the generation of the particle distribution to be kept
    in memory. Any time-dependence has to be defined before calling this namelist.

    Beam corresponds to Genesis 4 `beam`.

    Attributes
    ----------
    gamma : float, default=0.0
        Mean energy in units of the electron rest mass. If default value is given by
        the reference energy from the `setup`-namelist.
    delgam : float, default=0.0
        RMS energy spread in units of the electron rest mass.
    current : float, default=1000.0
        Current in Amperes.
    ex : float, default=3e-07
        Normalized emittance in $x$ in units of meters
    ey : float, default=3e-07
        Normalized emittance in $y$ in units of meters
    betax : float, default=15.0
        Initial beta-function in $x$ in meters. If the matched command has been invoked
        before the default values are set to the results.
    betay : float, default=15.0
        Initial beta-function in $y$ in meters. If the matched command has been invoked
        before the default values are set to the results.
    alphax : float, default=0.0
        Initial alpha-function in $x$. If the matched command has been invoked before
        the default values are set to the results.
    alphay : float, default=0.0
        Initial alpha-function in $y$. If the matched command has been invoked before
        the default values are set to the results.
    xcenter : float, default=0.0
        Initial centroid position in $x$ in meter.
    ycenter : float, default=0.0
        Initial centroid position in $y$ in meter.
    pxcenter : float, default=0.0
        Initial centroid momentum in $x$ in units of $\gamma \beta_x$.
    pycenter : float, default=0.0
        Initial centroid momentum in $y$ in units $\gamma \beta_y$.
    bunch : float, default=0.0
        Initial bunching value
    bunchphase : float, default=0.0
        Initial phase of the bunching
    emod : float, default=0.0
        Initial energy modulation in units of the electron rest mass. This modulation
        is on the scale of the reference wavelength
    emodphase : float, default=0.0
        Initial phase of the energy modulation
    """

    type: Literal["beam"] = "beam"
    gamma: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        Mean energy in units of the electron rest mass. If default value is given
        by the reference energy from the `setup`-namelist.
        """.strip(),
    )
    delgam: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"RMS energy spread in units of the electron rest mass.",
    )
    current: float | types.Reference = pydantic.Field(
        default=1000.0,
        description=r"Current in Amperes.",
    )
    ex: float | types.Reference = pydantic.Field(
        default=3e-07,
        description=r"Normalized emittance in $x$ in units of meters",
    )
    ey: float | types.Reference = pydantic.Field(
        default=3e-07,
        description=r"Normalized emittance in $y$ in units of meters",
    )
    betax: float | types.Reference = pydantic.Field(
        default=15.0,
        description=r"""
        Initial beta-function in $x$ in meters. If the matched command has been
        invoked before the default values are set to the results.
        """.strip(),
    )
    betay: float | types.Reference = pydantic.Field(
        default=15.0,
        description=r"""
        Initial beta-function in $y$ in meters. If the matched command has been
        invoked before the default values are set to the results.
        """.strip(),
    )
    alphax: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        Initial alpha-function in $x$. If the matched command has been invoked
        before the default values are set to the results.
        """.strip(),
    )
    alphay: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        Initial alpha-function in $y$. If the matched command has been invoked
        before the default values are set to the results.
        """.strip(),
    )
    xcenter: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial centroid position in $x$ in meter.",
    )
    ycenter: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial centroid position in $y$ in meter.",
    )
    pxcenter: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial centroid momentum in $x$ in units of $\gamma \beta_x$.",
    )
    pycenter: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial centroid momentum in $y$ in units $\gamma \beta_y$.",
    )
    bunch: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial bunching value",
    )
    bunchphase: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial phase of the bunching",
    )
    emod: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        Initial energy modulation in units of the electron rest mass. This
        modulation is on the scale of the reference wavelength
        """.strip(),
    )
    emodphase: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Initial phase of the energy modulation",
    )


class Field(types.NameList):
    r"""
    This namelist initiate the generation of the field distribution. It differs in
    one point from the generation of the beam. It can be called multiple times. If
    the variable `accumulate` is set to true, it does not delete the previous
    distribution but adds up the wavefronts. That way higher mode content in either
    spatial and time direction can be created.

    Field corresponds to Genesis 4 `field`.

    Attributes
    ----------
    lambda_ : float, default=0.0
        Central frequency of the radiation mode. The default value is the reference
        wavelength from the `setup`-namelist.
    power : float, default=0.0
        Radiation power in Watts
    phase : float, default=0.0
        radiation phase in rads. Note that a linear profile results in a shift in the
        radiation wavelength, which is also the method if for the variable `lambda` a
        different value than the reference wavelength is used. In case of conflicts the
        profile for the phase definition has priority.
    waist_pos : float, default=0.0
        Position where the focal point is located relative to the undulator entrance.
        Negative values place it before, resulting in a diverging radiation field.
    waist_size : float, default=1e-07
        Waist size according to the definition of $w_0$ according to Siegman’s ’Laser’
        handbook
    xcenter : float, default=0.0
        Center position in $x$ in meter of the Gauss-Hermite mode
    ycenter : float, default=0.0
        Center position in $y$ in meter of the Gauss-Hermite mode
    xangle : float, default=0.0
        Injection angle in $x$ in rad of the Gauss-Hermite mode
    yangle : float, default=0.0
        Injection angle in $y$ in rad of the Gauss-Hermite mode
    dgrid : float, default=0.001
        Grid extension from the center to one edge. The whole grid is twice as large
        with 0 as the center position
    ngrid : int, default=151
        Number of grid points in one dimension. This value should be odd to enforce a
        grid point directly on axis. Otherwise the convergence in the simulations could
        be worse.
    harm : int, default=1
        Harmonic number of the radiation field with respect to the reference
        wavelength.
    nx : int, default=0
        Mode number in $x$ of the Gauss-Hermite mode
    ny : int, default=0
        Mode number in $y$ of the Gauss-Hermite mode
    accumulate : bool, default=False
        If set the generated field is added to an existing field instead of overwriting
        it.
    """

    type: Literal["field"] = "field"
    lambda_: float = pydantic.Field(
        default=0.0,
        description=r"""
        Central frequency of the radiation mode. The default value is the
        reference wavelength from the `setup`-namelist.
        """.strip(),
        validation_alias=pydantic.AliasChoices("lambda_", "lambda"),
        serialization_alias="lambda",
    )
    power: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"Radiation power in Watts",
    )
    phase: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        radiation phase in rads. Note that a linear profile results in a shift in
        the radiation wavelength, which is also the method if for the variable
        `lambda` a different value than the reference wavelength is used. In case
        of conflicts the profile for the phase definition has priority.
        """.strip(),
    )
    waist_pos: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        Position where the focal point is located relative to the undulator
        entrance. Negative values place it before, resulting in a diverging
        radiation field.
        """.strip(),
    )
    waist_size: float | types.Reference = pydantic.Field(
        default=1e-07,
        description=r"""
        Waist size according to the definition of $w_0$ according to Siegman’s
        ’Laser’ handbook
        """.strip(),
    )
    xcenter: float = pydantic.Field(
        default=0.0,
        description=r"Center position in $x$ in meter of the Gauss-Hermite mode",
    )
    ycenter: float = pydantic.Field(
        default=0.0,
        description=r"Center position in $y$ in meter of the Gauss-Hermite mode",
    )
    xangle: float = pydantic.Field(
        default=0.0,
        description=r"Injection angle in $x$ in rad of the Gauss-Hermite mode",
    )
    yangle: float = pydantic.Field(
        default=0.0,
        description=r"Injection angle in $y$ in rad of the Gauss-Hermite mode",
    )
    dgrid: float = pydantic.Field(
        default=0.001,
        description=r"""
        Grid extension from the center to one edge. The whole grid is twice as
        large with 0 as the center position
        """.strip(),
    )
    ngrid: int = pydantic.Field(
        default=151,
        description=r"""
        Number of grid points in one dimension. This value should be odd to
        enforce a grid point directly on axis. Otherwise the convergence in the
        simulations could be worse.
        """.strip(),
    )
    harm: int = pydantic.Field(
        default=1,
        description=r"Harmonic number of the radiation field with respect to the reference wavelength.",
    )
    nx: int = pydantic.Field(
        default=0,
        description=r"Mode number in $x$ of the Gauss-Hermite mode",
    )
    ny: int = pydantic.Field(
        default=0,
        description=r"Mode number in $y$ of the Gauss-Hermite mode",
    )
    accumulate: bool = pydantic.Field(
        default=False,
        description=r"""
        If set the generated field is added to an existing field instead of
        overwriting it.
        """.strip(),
    )


class ImportDistribution(types.NameList):
    r"""
    This namelist controls the import of an external distribution which are
    generated from Elegant. The file has to be in HDF5 format. In the distribution
    is a shell script to convert an Elegant sdds-output file into the HDF5 format.
    The distribution has to provide all 6 dimensions while the charge is supplied
    in this namelist. When imported the longitudinal position is changed so that
    the last particles is at $s=0$ micron.

    Note that this namelist will be expanded in the future, to enable tilts and
    match/center to a core part of the beam

    ImportDistribution corresponds to Genesis 4 `importdistribution`.

    Attributes
    ----------
    file : str, default=""
        The file name of the distribution, including possible relative directories.
    charge : float, default=0.0
        Total charge of the distribution to calculate the current and individual charge
        per macro particle.
    slicewidth : float, default=0.01
        the fraction in length of the distribution which is used for reconstruction.
        E.g if the length is 10 micron and slic ewidth 0.02 then the reconstruction at
        the positions $s= 4\,\mu m$ is using those particles in the distribution, which
        are located in the slice from $3.9\, \mu m$ to $4.1\,\mu m$.
    center : bool, default=False
        If set to true the particle distribution is recentered in transverse position,
        momenta and energy.
    gamma0 : float, default=0.0
        If centering is enabled, new center in energy in units of electron rest mass.
    x0 : float, default=0.0
        If centering is enabled, new center in $x$ in meter.
    y0 : float, default=0.0
        If centering is enabled, new center in $y$ in meter.
    px0 : float, default=0.0
        If centering is enabled, new mean momentum in $x$ in $\gamma \beta_x$.
    py0 : float, default=0.0
        If centering is enabled, new mean momentum in y in $\gamma \beta_y$.
    match : bool, default=False
        If set to `true`, the particle distribution is matched to new optical function
        values.
    betax : float, default=15.0
        If matching is enabled, new beta function in $x$ in meters.
    betay : float, default=15.0
        If matching is enabled, new beta function in $y$ in meters.
    alphax : float, default=0.0
        If matching is enabled, new alpha function in $x$.
    alphay : float, default=0.0
        If matching is enabled, new alpha function in $y$.
    eval_start : float, default=0.0
        evaluation start.
    eval_end : float, default=1.0
        evaluation end.
    settimewindow : bool, default=True
        set time window.
    align : int, default=0
        currently unused.
    align_start : float, default=0.0
        currently unused.
    align_end : float, default=1.0
        currently unused.
    """

    type: Literal["importdistribution"] = "importdistribution"
    file: str = pydantic.Field(
        default="",
        description=r"The file name of the distribution, including possible relative directories.",
    )
    charge: float = pydantic.Field(
        default=0.0,
        description=r"""
        Total charge of the distribution to calculate the current and individual
        charge per macro particle.
        """.strip(),
    )
    slicewidth: float = pydantic.Field(
        default=0.01,
        description=r"""
        the fraction in length of the distribution which is used for
        reconstruction. E.g if the length is 10 micron and slic ewidth 0.02 then
        the reconstruction at the positions $s= 4\,\mu m$ is using those particles
        in the distribution, which are located in the slice from $3.9\, \mu m$ to
        $4.1\,\mu m$.
        """.strip(),
    )
    center: bool = pydantic.Field(
        default=False,
        description=r"""
        If set to true the particle distribution is recentered in transverse
        position, momenta and energy.
        """.strip(),
    )
    gamma0: float = pydantic.Field(
        default=0.0,
        description=r"If centering is enabled, new center in energy in units of electron rest mass.",
    )
    x0: float = pydantic.Field(
        default=0.0,
        description=r"If centering is enabled, new center in $x$ in meter.",
    )
    y0: float = pydantic.Field(
        default=0.0,
        description=r"If centering is enabled, new center in $y$ in meter.",
    )
    px0: float = pydantic.Field(
        default=0.0,
        description=r"If centering is enabled, new mean momentum in $x$ in $\gamma \beta_x$.",
    )
    py0: float = pydantic.Field(
        default=0.0,
        description=r"If centering is enabled, new mean momentum in y in $\gamma \beta_y$.",
    )
    match: bool = pydantic.Field(
        default=False,
        description=r"""
        If set to `true`, the particle distribution is matched to new optical
        function values.
        """.strip(),
    )
    betax: float = pydantic.Field(
        default=15.0,
        description=r"If matching is enabled, new beta function in $x$ in meters.",
    )
    betay: float = pydantic.Field(
        default=15.0,
        description=r"If matching is enabled, new beta function in $y$ in meters.",
    )
    alphax: float = pydantic.Field(
        default=0.0,
        description=r"If matching is enabled, new alpha function in $x$.",
    )
    alphay: float = pydantic.Field(
        default=0.0,
        description=r"If matching is enabled, new alpha function in $y$.",
    )
    eval_start: float = pydantic.Field(
        default=0.0,
        description=r"evaluation start.",
    )
    eval_end: float = pydantic.Field(
        default=1.0,
        description=r"evaluation end.",
    )
    settimewindow: bool = pydantic.Field(
        default=True,
        description=r"set time window.",
    )
    align: int = pydantic.Field(
        default=0,
        description=r"currently unused.",
    )
    align_start: float = pydantic.Field(
        default=0.0,
        description=r"currently unused.",
    )
    align_end: float = pydantic.Field(
        default=1.0,
        description=r"currently unused.",
    )


class ImportBeam(types.NameList):
    r"""
    The modules controls the import of a Genesis 1.3 particle file to replace the
    internal generation of the particle distribution (note that the module `beam`
    should not be called). The routine defines also the parameter for a time-
    dependent run if the `time`-namelist hasn’t been defined yet.

    ImportBeam corresponds to Genesis 4 `importbeam`.

    Attributes
    ----------
    file : str, default=""
        File name of a hdf5 complient datafile to contain the slice-wise particle
        distribution. It has to follow the internal Genesis 1.3 syntax.
    time : bool, default=True
        If the time window hasn’t be defined it allows to run Genesis with the imported
        distribution in scan mode, when set to `false`. This would disable all slippage
        and long-range collective effects in the simulation
    """

    type: Literal["importbeam"] = "importbeam"
    file: str = pydantic.Field(
        default="",
        description=r"""
        File name of a hdf5 complient datafile to contain the slice-wise particle
        distribution. It has to follow the internal Genesis 1.3 syntax.
        """.strip(),
    )
    time: bool = pydantic.Field(
        default=True,
        description=r"""
        If the time window hasn’t be defined it allows to run Genesis with the
        imported distribution in scan mode, when set to `false`. This would
        disable all slippage and long-range collective effects in the simulation
        """.strip(),
    )


class ImportField(types.NameList):
    r"""
    The modules controls the import of a Genesis 1.3 field file to replace the
    internal generation of the field distribution (note that the module `field`
    should only be called afterwards with the `accumulate`-option enabled). The
    routine defines also the parameter for a time-dependent run if the
    `time`-namelist hasn’t been defined yet.

    ImportField corresponds to Genesis 4 `importfield`.

    Attributes
    ----------
    file : str, default=""
        File name of a hdf5 compliant datafile to contain the slice-wise particle
        distribution. It has to follow the internal Genesis 1.3 syntax.
    harmonic : int, default=1
        defines the harmonic for the given Genesis run.
    time : bool, default=True
        If the time window hasn’t be defined it allows to run Genesis with the imported
        distribution in scan mode, when set to `false`. This would disable all slippage
        and long-range collective effects in the simulation
    """

    type: Literal["importfield"] = "importfield"
    file: str = pydantic.Field(
        default="",
        description=r"""
        File name of a hdf5 compliant datafile to contain the slice-wise particle
        distribution. It has to follow the internal Genesis 1.3 syntax.
        """.strip(),
    )
    harmonic: int = pydantic.Field(
        default=1,
        description=r"defines the harmonic for the given Genesis run.",
    )
    time: bool = pydantic.Field(
        default=True,
        description=r"""
        If the time window hasn’t be defined it allows to run Genesis with the
        imported distribution in scan mode, when set to `false`. This would
        disable all slippage and long-range collective effects in the simulation
        """.strip(),
    )


class ImportTransformation(types.NameList):
    r"""
    Once an electron distribution is generated the namelist can be used to
    manipulate the distribution by shifting the particle by the vector dr or
    applying the transport matrix R. The applied transformation is `r1 = R*r0+dr`,
    where
    `r0` is the initial particle vector and `r1` the final one. The transformation
    assumes the standard 6D vector of `(x,x',y,y',s,delta)`.
    the supplied vector and matrix must have the corresponding shape (6 or 6x6).
    The user can supply more than one vector or matrix, e.g. sampling at various
    positions `s`. Then the transformation used interpolated values.
    Note that in the case of transport matrices and interpolated matrix does not
    preserve the emittance. In this case a high sample rate should be supplied to
    reduce this effect to a minimum.
    Genesis will check the shape of the transport vector and matrices. If the rank
    is higher than needed (e.g. 2x6x6 for a transport matrix) then it assumes the
    first index
    refers to the sample along the `s`-axis. In this case the sample distance
    `slen` should be also specified. In the case that `n=1` or `slen=0` only a
    global transformation is applied.

    ImportTransformation corresponds to Genesis 4 `importtransformation`.

    Attributes
    ----------
    file : str, default=""
        File name of a hdf5 compliant datafile to contain the vector and matrix
        informations
    vector : str, default=""
        Name of the dataset which contains the vector information. The shape must be
        either (6) or (n,6)
    matrix : str, default=""
        Name of the dataset which contains the matrix information. The shape must be
        either (6,6) or (n,6,6)
    slen : float, default=0.0
        The length in meters between adjacent sample points (n>1), needed for the
        interpolation. If the value is zero only a global transformation is applied
        using the first entry.
    """

    type: Literal["importtransformation"] = "importtransformation"
    file: str = pydantic.Field(
        default="",
        description=r"""
        File name of a hdf5 compliant datafile to contain the vector and matrix
        informations
        """.strip(),
    )
    vector: str = pydantic.Field(
        default="",
        description=r"""
        Name of the dataset which contains the vector information. The shape must
        be either (6) or (n,6)
        """.strip(),
    )
    matrix: str = pydantic.Field(
        default="",
        description=r"""
        Name of the dataset which contains the matrix information. The shape must
        be either (6,6) or (n,6,6)
        """.strip(),
    )
    slen: float = pydantic.Field(
        default=0.0,
        description=r"""
        The length in meters between adjacent sample points (n>1), needed for the
        interpolation. If the value is zero only a global transformation is
        applied using the first entry.
        """.strip(),
    )


class Efield(types.NameList):
    r"""
    This namelist controls the long and short range space charge fields. The long
    range corresponds to any length scale longer than the slice length of the
    simulation, while the short range is on the resonant wavelength scale.
    Numerically they are treated differently.
    The calculation for the short range is done on a radial-azimuthal grid,
    centered to the centroid position of the electron slice, while the long range
    is the sum of the space charge field in the rest frame where each slice is
    treated as a uniform disk.

    Efield corresponds to Genesis 4 `efield`.

    Attributes
    ----------
    longrange : bool, default=False
        Flag to enable the calculation of the long range space charge field.
    rmax : float, default=0.0
        Size of radial grid in meters. If the beam size gets larger than the grid the
        size is automatically adjusted to the maximum radius of the electrons with an
        additional 50% extension. When the mesh size is adjusted a message will be
        printed on screen.
    nz : int, default=0
        Number of longitudinal Fourier component of the short range space charge field.
        Note that this should be not in conflict with the beamlet size.
    nphi : int, default=0
        Number of azimuthal modes in the calculation of the short range space charge
        field.
    ngrid : int, default=100
        Number of grid points of the radial grid for the short range space charge
        field.
    """

    type: Literal["efield"] = "efield"
    longrange: bool = pydantic.Field(
        default=False,
        description=r"Flag to enable the calculation of the long range space charge field.",
    )
    rmax: float = pydantic.Field(
        default=0.0,
        description=r"""
        Size of radial grid in meters. If the beam size gets larger than the grid
        the size is automatically adjusted to the maximum radius of the electrons
        with an additional 50% extension. When the mesh size is adjusted a message
        will be printed on screen.
        """.strip(),
    )
    nz: int = pydantic.Field(
        default=0,
        description=r"""
        Number of longitudinal Fourier component of the short range space charge
        field. Note that this should be not in conflict with the beamlet size.
        """.strip(),
    )
    nphi: int = pydantic.Field(
        default=0,
        description=r"""
        Number of azimuthal modes in the calculation of the short range space
        charge field.
        """.strip(),
    )
    ngrid: int = pydantic.Field(
        default=100,
        description=r"Number of grid points of the radial grid for the short range space charge field.",
    )


class Sponrad(types.NameList):
    r"""
    This enables the effect of spontaneous radiation outside of the frequency band
    of the FEL simulation.

    Sponrad corresponds to Genesis 4 `sponrad`.

    Attributes
    ----------
    seed : int, default=1234
        Seed for random number generator to model the quantum fluctuation of hard
        photons.
    doLoss : bool, default=False
        If set to `true`, electrons will loose energy due to the emission of
        spontaneous radiation within the undulator
    doSpread : bool, default=False
        If set to `true`, the energy spread will increase due to the fluctuation in the
        emission of hard photons of the spontaneous radiation.
    """

    type: Literal["sponrad"] = "sponrad"
    seed: int = pydantic.Field(
        default=1234,
        description=r"""
        Seed for random number generator to model the quantum fluctuation of hard
        photons.
        """.strip(),
    )
    doLoss: bool = pydantic.Field(
        default=False,
        description=r"""
        If set to `true`, electrons will loose energy due to the emission of
        spontaneous radiation within the undulator
        """.strip(),
    )
    doSpread: bool = pydantic.Field(
        default=False,
        description=r"""
        If set to `true`, the energy spread will increase due to the fluctuation
        in the emission of hard photons of the spontaneous radiation.
        """.strip(),
    )


class Wake(types.NameList):
    r"""
    Genesis supports the calculation of three types of wakefields by specifying the
    typical input parameters (e.g. gap length for the geometric wakefield). It
    first solves the single particle wake and then convolutes with the current
    distribution. Therefore it follows the change in the wakepotential if a chirped
    beams undergoes a compression in a chicane. In addition an external loss factor
    can be supplied, which can also refer to a profile. In this case it is treated
    as the full wake and subtracted from the particle energy directly.

    *Note that this functionality hasn't been fully tested yet or optimized for
    rapid calculation*

    Wake corresponds to Genesis 4 `wake`.

    Attributes
    ----------
    loss : float, default=0.0
        Loss in $eV/m$. This is a global loss function (in particular if a profile is
        defined). Its function values V(s) remains unchanged even if the current
        profile changes
    radius : float, default=0.0025
        Radius of the aperture if it is a round chanber or half the distance in the
        case of two parallel plates.
    roundpipe : bool, default=True
        Flag to indicate the shape of the transverse cross-section of the aperture. If
        set to `true`, a round aperture is assumed, otherwise the model has two
        parallel plates.
    conductivity : float, default=0.0
        Conductivity of the vacuum material for the resistive wall wakefield function
    relaxation : float, default=0.0
        Relaxation distance (aka the mean free path of the electron in the vacuum
        material) for the resistive wall wakefields
    material : str, default=""
        String literal to define conductivity and relaxation distance for either copper
        or aluminum by using the two character label ’CU’ or ’AL’ repectively. This
        overwrites also any explicit definition of the conductivity and relaxation
        value.
    gap : float, default=0.0
        Length in mm of a longitudinal gap in the aperture, exciting geometric wakes.
    lgap : float, default=1.0
        Effective length over which a single gap is applied. E.g. if there is a
        periodicity of 4.5 m at which there is always the same gap in the aperture for
        the geometrice wakes, then this value should be put to 4.5 m.
    hrough : float, default=0.0
        Amplitude in meters of a sinusoidal corrugation, modeling the effect of surface
        roughness wakes.
    lrough : float, default=1.0
        period lengthin meters of the sinusoidal corrugation of the surface roughness
        model.
    transient : bool, default=False
        If set to `true`, Genesis includes the catch-up length of the origin of the
        wakefield to the particle effects. E.g. particles do not see immediatly the
        wake from those closer ahead of them than those further away. The catch-up
        distance is the distance in the undulator added to the starting position
        `ztrans`. If set to false the steady-state model is used, effectively setting
        `ztrans` to infinity. Enabling transient calculation will update the wakefield
        at each integration step, which can slow down the calculations.
    ztrans : float, default=0.0
        Reference location of the first source of the wake fields. A positive value
        means that the condition for wakes (e.g. a small aperture in the vacuum
        chamber) has already started and there has been already some length to
        establish the wakes. For a value of zero the source is right at the undulator
        start, while a negative value prevents any wake, till the interation position
        has passed that point.
    """

    type: Literal["wake"] = "wake"
    loss: float | types.Reference = pydantic.Field(
        default=0.0,
        description=r"""
        Loss in $eV/m$. This is a global loss function (in particular if a profile
        is defined). Its function values V(s) remains unchanged even if the
        current profile changes
        """.strip(),
    )
    radius: float = pydantic.Field(
        default=0.0025,
        description=r"""
        Radius of the aperture if it is a round chanber or half the distance in
        the case of two parallel plates.
        """.strip(),
    )
    roundpipe: bool = pydantic.Field(
        default=True,
        description=r"""
        Flag to indicate the shape of the transverse cross-section of the
        aperture. If set to `true`, a round aperture is assumed, otherwise the
        model has two parallel plates.
        """.strip(),
    )
    conductivity: float = pydantic.Field(
        default=0.0,
        description=r"Conductivity of the vacuum material for the resistive wall wakefield function",
    )
    relaxation: float = pydantic.Field(
        default=0.0,
        description=r"""
        Relaxation distance (aka the mean free path of the electron in the vacuum
        material) for the resistive wall wakefields
        """.strip(),
    )
    material: str = pydantic.Field(
        default="",
        description=r"""
        String literal to define conductivity and relaxation distance for either
        copper or aluminum by using the two character label ’CU’ or ’AL’
        repectively. This overwrites also any explicit definition of the
        conductivity and relaxation value.
        """.strip(),
    )
    gap: float = pydantic.Field(
        default=0.0,
        description=r"Length in mm of a longitudinal gap in the aperture, exciting geometric wakes.",
    )
    lgap: float = pydantic.Field(
        default=1.0,
        description=r"""
        Effective length over which a single gap is applied. E.g. if there is a
        periodicity of 4.5 m at which there is always the same gap in the aperture
        for the geometrice wakes, then this value should be put to 4.5 m.
        """.strip(),
    )
    hrough: float = pydantic.Field(
        default=0.0,
        description=r"""
        Amplitude in meters of a sinusoidal corrugation, modeling the effect of
        surface roughness wakes.
        """.strip(),
    )
    lrough: float = pydantic.Field(
        default=1.0,
        description=r"""
        period lengthin meters of the sinusoidal corrugation of the surface
        roughness model.
        """.strip(),
    )
    transient: bool = pydantic.Field(
        default=False,
        description=r"""
        If set to `true`, Genesis includes the catch-up length of the origin of
        the wakefield to the particle effects. E.g. particles do not see
        immediatly the wake from those closer ahead of them than those further
        away. The catch-up distance is the distance in the undulator added to the
        starting position `ztrans`. If set to false the steady-state model is
        used, effectively setting `ztrans` to infinity. Enabling transient
        calculation will update the wakefield at each integration step, which can
        slow down the calculations.
        """.strip(),
    )
    ztrans: float = pydantic.Field(
        default=0.0,
        description=r"""
        Reference location of the first source of the wake fields. A positive
        value means that the condition for wakes (e.g. a small aperture in the
        vacuum chamber) has already started and there has been already some length
        to establish the wakes. For a value of zero the source is right at the
        undulator start, while a negative value prevents any wake, till the
        interation position has passed that point.
        """.strip(),
    )


class Write(types.NameList):
    r"""
    With this name list the field or particle distributions are dumped. The
    placeholder character `@` can be used to refer to the rootname of the
    simulation run, e.g. `field = @.final`

    Write corresponds to Genesis 4 `write`.

    Attributes
    ----------
    field : str, default=""
        if a filename is defined, Genesis writes out the field distribution of all
        harmonics. The harmonics are indicated by the suffix ’.hxxx.’ where xxx is the
        harmonic number. The filename gets the extension.fld.h5 automatically
    beam : str, default=""
        if a filename is defined, Genesis writes out the particle distribution. The
        filename gets the `extension.par.h5` automatically
    stride : int, default=1
        For values larger than 1 the amount of particles written to the file is reduced
        by only writing each *stride*th particle to the dump file.
    """

    type: Literal["write"] = "write"
    field: str = pydantic.Field(
        default="",
        description=r"""
        if a filename is defined, Genesis writes out the field distribution of all
        harmonics. The harmonics are indicated by the suffix ’.hxxx.’ where xxx is
        the harmonic number. The filename gets the extension.fld.h5 automatically
        """.strip(),
    )
    beam: str = pydantic.Field(
        default="",
        description=r"""
        if a filename is defined, Genesis writes out the particle distribution.
        The filename gets the `extension.par.h5` automatically
        """.strip(),
    )
    stride: int = pydantic.Field(
        default=1,
        description=r"""
        For values larger than 1 the amount of particles written to the file is
        reduced by only writing each *stride*th particle to the dump file.
        """.strip(),
    )


class Track(types.NameList):
    r"""
    This namelist initiate the actually tracking through the undulator and then
    writing out the results. Normally all parameter should be defined before or
    defined in the lattice but the namelist allows some ’last minute’ change of the
    behavior of the code

    Track corresponds to Genesis 4 `track`.

    Attributes
    ----------
    zstop : float, default=1000000000.0
        If `zstop` is shorter than the lattice length the tracking stops at the
        specified position.
    output_step : int, default=1
        Defines the number of integration steps before the particle and field
        distribution is analyzed for output.
    field_dump_step : int, default=0
        Defines the number of integration steps before a field dump is written. Be
        careful because for time-dependent simulation it can generate many large output
        files.
    beam_dump_step : int, default=0
        Defines the number of integration steps before a particle dump is written. Be
        careful because for time-dependent simulation it can generate many large output
        files.
    sort_step : int, default=0
        Defines the number of steps of integration before the particle distribution is
        sorted. Works only for one-4-one simulations.
    s0 : float, default=0.0
        Option to override the default time window start from the TIME module.
    slen : float, default=0.0
        Option to override the default time window length from the TIME module.
    field_dump_at_undexit : bool, default=False
        Field dumps at the exit of the undulator (one dump for each undulator in the
        expanded lattice).
    bunchharm : int, default=1
        Bunching harmonic output setting. Must be >= 1.
    """

    type: Literal["track"] = "track"
    zstop: float = pydantic.Field(
        default=1000000000.0,
        description=r"""
        If `zstop` is shorter than the lattice length the tracking stops at the
        specified position.
        """.strip(),
    )
    output_step: int = pydantic.Field(
        default=1,
        description=r"""
        Defines the number of integration steps before the particle and field
        distribution is analyzed for output.
        """.strip(),
    )
    field_dump_step: int = pydantic.Field(
        default=0,
        description=r"""
        Defines the number of integration steps before a field dump is written. Be
        careful because for time-dependent simulation it can generate many large
        output files.
        """.strip(),
    )
    beam_dump_step: int = pydantic.Field(
        default=0,
        description=r"""
        Defines the number of integration steps before a particle dump is written.
        Be careful because for time-dependent simulation it can generate many
        large output files.
        """.strip(),
    )
    sort_step: int = pydantic.Field(
        default=0,
        description=r"""
        Defines the number of steps of integration before the particle
        distribution is sorted. Works only for one-4-one simulations.
        """.strip(),
    )
    s0: float = pydantic.Field(
        default=0.0,
        description=r"Option to override the default time window start from the TIME module.",
    )
    slen: float = pydantic.Field(
        default=0.0,
        description=r"Option to override the default time window length from the TIME module.",
    )
    field_dump_at_undexit: bool = pydantic.Field(
        default=False,
        description=r"""
        Field dumps at the exit of the undulator (one dump for each undulator in
        the expanded lattice).
        """.strip(),
    )
    bunchharm: int = pydantic.Field(
        default=1,
        description=r"Bunching harmonic output setting. Must be >= 1.",
    )


class AlterField(types.NameList):
    r"""
    Field manipulator (TODO).

    Note that the namelist `field_manipulator` is deprecated and will be removed in
    the future. Use `alter_field` instead.

    AlterField corresponds to Genesis 4 `alter_field`.

    Attributes
    ----------
    harm : int, default=1
        harmonic
    scale_power : float, default=1.0
        power scaling factor
    spp_l : float, default=0.0
        TODO
    spp_nsect : int, default=0
        TODO
    spp_phi0 : float, default=0.0
        TODO
    """

    type: Literal["alter_field"] = "alter_field"
    harm: int = pydantic.Field(
        default=1,
        description=r"harmonic",
    )
    scale_power: float = pydantic.Field(
        default=1.0,
        description=r"power scaling factor",
    )
    spp_l: float = pydantic.Field(
        default=0.0,
        description=r"TODO",
    )
    spp_nsect: int = pydantic.Field(
        default=0,
        description=r"TODO",
    )
    spp_phi0: float = pydantic.Field(
        default=0.0,
        description=r"TODO",
    )


class ProfileFileMulti(types.NameList):
    r"""
    Generates profile objects `<label_prefix>.gamma`, `<label_prefix>.delgam`,
    `<label_prefix>.current`, etc., each one corresponding to one `&profile_file`.

    ProfileFileMulti corresponds to Genesis 4 `profile_file_multi`.

    Attributes
    ----------
    file : str, default=""
        HDF5 filename.
    label_prefix : str, default=""
        prefix for each object.
    xdata : str, default=""
        Points to a dataset in an HDF5 file to define the `s`-position for the look-up
        table. The format is `filename/group1/.../groupn/datasetname`, where the naming
        of groups is not required if the dataset is at root level of the HDF file
    ydata : str, default=""
        Same as y data but for the function values of the look-up table.
    isTime : bool, default=False
        If true the `s`-position is a time variable and therefore multiplied with the
        speed of light `c` to get the position in meters.
    reverse : bool, default=False
        if true the order in the look-up table is reverse. This is sometimes needed
        because time and spatial coordinates differ sometimes by a minus sign.
    """

    type: Literal["profile_file_multi"] = "profile_file_multi"
    file: str = pydantic.Field(
        default="",
        description=r"HDF5 filename.",
    )
    label_prefix: str = pydantic.Field(
        default="",
        description=r"prefix for each object.",
    )
    xdata: str = pydantic.Field(
        default="",
        description=r"""
        Points to a dataset in an HDF5 file to define the `s`-position for the
        look-up table. The format is `filename/group1/.../groupn/datasetname`,
        where the naming of groups is not required if the dataset is at root level
        of the HDF file
        """.strip(),
    )
    ydata: str = pydantic.Field(
        default="",
        description=r"Same as y data but for the function values of the look-up table.",
    )
    isTime: bool = pydantic.Field(
        default=False,
        description=r"""
        If true the `s`-position is a time variable and therefore multiplied with
        the speed of light `c` to get the position in meters.
        """.strip(),
    )
    reverse: bool = pydantic.Field(
        default=False,
        description=r"""
        if true the order in the look-up table is reverse. This is sometimes
        needed because time and spatial coordinates differ sometimes by a minus
        sign.
        """.strip(),
    )


class SequenceList(types.NameList):
    r"""
    A sequence of values given as a string.

    SequenceList corresponds to Genesis 4 `sequence_list`.

    Attributes
    ----------
    label : str
        label for the sequence.
    val : float, default=[]
        list of values.
    default : float, default=0.0
        default value to use for out-of-bound indices.
    """

    type: Literal["sequence_list"] = "sequence_list"
    label: str = pydantic.Field(
        description=r"label for the sequence.",
    )
    val: types.PydanticNDArray = pydantic.Field(
        default_factory=list,
        description=r"list of values.",
    )
    default: float = pydantic.Field(
        default=0.0,
        description=r"default value to use for out-of-bound indices.",
    )


class SequenceFilelist(types.NameList):
    r"""
    A sequence list with data in a file.

    SequenceFilelist corresponds to Genesis 4 `sequence_filelist`.

    Attributes
    ----------
    label : str
        label for the sequence.
    file : str, default=""
        filename to load the sequence from with one line per value.
    """

    type: Literal["sequence_filelist"] = "sequence_filelist"
    label: str = pydantic.Field(
        description=r"label for the sequence.",
    )
    file: str = pydantic.Field(
        default="",
        description=r"filename to load the sequence from with one line per value.",
    )


AutogeneratedNameList = Union[
    Setup,
    AlterSetup,
    Lattice,
    Time,
    ProfileConst,
    ProfileGauss,
    ProfileStep,
    ProfilePolynom,
    ProfileFile,
    SequenceConst,
    SequencePolynom,
    SequencePower,
    SequenceRandom,
    Beam,
    Field,
    ImportDistribution,
    ImportBeam,
    ImportField,
    ImportTransformation,
    Efield,
    Sponrad,
    Wake,
    Write,
    Track,
    AlterField,
    ProfileFileMulti,
    SequenceList,
    SequenceFilelist,
]
