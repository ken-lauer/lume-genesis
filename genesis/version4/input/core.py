from __future__ import annotations

import logging
import os
import pathlib
import shlex
import shutil
import typing
from contextlib import contextmanager
from inspect import isclass
from typing import (
    Any,
    Dict,
    Generator,
    List,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
)

import h5py
import lark
import numpy as np
import pydantic
from lume import tools as lume_tools
from pmd_beamphysics import ParticleGroup
from pmd_beamphysics.units import c_light

from ... import tools
from ..types import (
    AnyPath,
    BaseModel,
    BeamlineElement,
    NameList,
    ParticleData,
    NDArray,
    Reference,
    ValueType,
    union_types,
)
from . import util
from ._main import (
    ImportBeam,
    ImportDistribution,
    ImportField,
    ImportTransformation,
    ProfileFile,
    ProfileFileMulti,
    SequenceFilelist,
    Setup,
)
from . import _main as auto_main
from . import _lattice as auto_lattice
from ..particles import load_particle_group


try:
    from typing import Literal
except ImportError:
    from typing_extensions import Literal


AnyNameList = Union[
    auto_main.AutogeneratedNameList,
    "ProfileArray",
    "InitialParticles",
]
AnyBeamlineElement = Union[
    auto_lattice.AutogeneratedBeamlineElement,
    "Line",
]


T_NameList = TypeVar("T_NameList", bound=NameList)
T_BeamlineElement = TypeVar("T_BeamlineElement", bound=BeamlineElement)

LineItem = Union[str, "DuplicatedLineItem", "PositionedLineItem", AnyBeamlineElement]

LATTICE_GRAMMAR = pathlib.Path("version4") / "input" / "lattice.lark"
MAIN_INPUT_GRAMMAR = pathlib.Path("version4") / "input" / "main_input.lark"

logger = logging.getLogger(__name__)


class DuplicatedLineItem(BaseModel):
    """
    A Genesis 4 lattice Line item which is at a certain position.

    This corresponds to Genesis 4 `"COUNT*LABEL"`.

    Attributes
    ----------
    label : str
        The name/label of the line item.
    count : int
        The number of times to repeat the line item.
    """

    label: str
    count: int

    @classmethod
    def from_string(cls, value: str) -> DuplicatedLineItem:
        count, label = value.split("*", 1)
        return cls(
            label=label.strip(),
            count=int(count),
        )

    def to_genesis(self) -> str:
        return str(self)

    def __str__(self) -> str:
        return f"{self.count}*{self.label}"


class PositionedLineItem(BaseModel):
    """
    A Genesis 4 lattice Line item which is at a certain position.

    This corresponds to Genesis 4 `"LABEL@POSITION"`.

    Attributes
    ----------
    label : str
        The name/label of the line item.
    position : float
        The position of the element.
    """

    label: str
    position: float

    @classmethod
    def from_string(cls, value: str) -> PositionedLineItem:
        label, position = value.split("@", 1)
        return cls(
            label=label.strip(),
            position=float(position.strip()),
        )

    def to_genesis(self) -> str:
        return str(self)

    def __str__(self) -> str:
        return f"{self.label}@{self.position}"


def _fix_line_item(line_item: LineItem) -> LineItem:
    """Make the appropriate dataclass for a serialized line item, if necessary."""
    if isinstance(line_item, (DuplicatedLineItem, PositionedLineItem)):
        return line_item
    if isinstance(line_item, BeamlineElement):
        return line_item
    if "@" in line_item:
        return PositionedLineItem.from_string(line_item)
    if "*" in line_item:
        return DuplicatedLineItem.from_string(line_item)
    return line_item


class Line(BeamlineElement):
    """
    A Genesis 4 beamline Line.

    Attributes
    ----------
    elements : list of LineItem
        Elements contained in the line.
    label : str, optional
        An optional label to attach to the line.
    """

    type: Literal["line"] = "line"
    elements: List[LineItem] = pydantic.Field(default_factory=list)
    label: str = ""

    def model_post_init(self, __context: Any) -> None:
        self.elements = [_fix_line_item(item) for item in self.elements]

    @property
    def _string_elements(self) -> List[str]:
        return [
            elem.label if isinstance(elem, BeamlineElement) else str(elem)
            for elem in self.elements
        ]

    def to_genesis(self) -> str:
        elements = ", ".join(self._string_elements)
        return "".join(
            (
                self.label,
                ": LINE = {",
                elements,
                "};",
            )
        )

    @classmethod
    def from_labels(
        cls,
        elements: Dict[str, AnyBeamlineElement],
        *element_labels: str,
        label: str = "",
    ) -> Line:
        """
        Create a `Line` from labeled beamline elements.

        Parameters
        ----------
        elements : Dict[str, BeamlineElement]
            The element dictionary.
        *element_labels : str
            Labels of elements.  May be either a single label per argument or a
            whitespace-delimited string of labels.
        label : str
            Label name for the line.

        Returns
        -------
        Line
        """
        try:
            return cls(
                elements=[
                    elements[label]
                    for labels in element_labels
                    for label in labels.strip().split()
                ],
                label=label,
            )
        except KeyError as ex:
            raise ValueError(
                f"Label {ex} is not present in the beamline element dictionary. "
                f"The following are valid: {tuple(elements.keys())}"
            )


class Lattice(BaseModel):
    """
    A Genesis 4 beamline Lattice configuration.

    Attributes
    ----------
    elements : list of BeamlineElement or Line
        Elements contained in the lattice.
    filename : pathlib.Path or None
        The filename from which this lattice was loaded.
    """

    elements: Dict[str, AnyBeamlineElement] = pydantic.Field(default_factory=dict)
    filename: Optional[pathlib.Path] = None

    def _repr_table_data_(self):
        return {
            "obj": self.elements,
            "annotations": None,
            "descriptions": None,
        }

    def __str__(self) -> str:
        return self.to_string("repr")

    def _repr_html_(self) -> str:
        repr_ = self.to_string("repr")
        return f"<pre>{repr_}</pre>"

    def to_genesis(self) -> str:
        self.fix_labels()
        return "\n".join(element.to_genesis() for element in self.elements.values())

    def fix_labels(self) -> None:
        for label, element in self.elements.items():
            if element.label != label:
                if element.label:
                    logger.warning(
                        "Renaming beamline element in lattice from %s to %s",
                        element.label,
                        label,
                    )
                element.label = label

    @property
    def by_element(self) -> Dict[Type[T_BeamlineElement], List[T_BeamlineElement]]:
        """Get beamline elements organized by their class."""
        by_element = {}
        for element in self.elements.values():
            by_element.setdefault(type(element), [])
            by_element[type(element)].append(element)
        return by_element

    @property
    def undulators(self) -> List[auto_lattice.Undulator]:
        return self.by_element.get(auto_lattice.Undulator, [])

    @property
    def drifts(self) -> List[auto_lattice.Drift]:
        return self.by_element.get(auto_lattice.Drift, [])

    @property
    def quadrupoles(self) -> List[auto_lattice.Quadrupole]:
        return self.by_element.get(auto_lattice.Quadrupole, [])

    @property
    def correctors(self) -> List[auto_lattice.Corrector]:
        return self.by_element.get(auto_lattice.Corrector, [])

    @property
    def chicanes(self) -> List[auto_lattice.Chicane]:
        return self.by_element.get(auto_lattice.Chicane, [])

    @property
    def phase_shifters(self) -> List[auto_lattice.PhaseShifter]:
        return self.by_element.get(auto_lattice.PhaseShifter, [])

    @property
    def markers(self) -> List[auto_lattice.Marker]:
        return self.by_element.get(auto_lattice.Marker, [])

    @property
    def lines(self) -> List[Line]:
        return self.by_element.get(Line, [])

    def model_dump(self, **kwargs) -> Dict[str, Dict]:
        """Serialize this lattice to a list of dictionaries."""
        self.fix_labels()
        return super().model_dump(**kwargs)

    @classmethod
    def from_contents(
        cls, contents: str, filename: Optional[AnyPath] = None
    ) -> Lattice:
        """
        Load a lattice from its file contents.

        Parameters
        ----------
        contents : str
            The contents of the lattice file.
        filename : AnyPath or None, optional
            The filename of the lattice, if known.

        Returns
        -------
        Lattice
        """
        parser = new_lattice_parser()
        filename = filename or "unknown"
        try:
            tree = parser.parse(contents)
        except Exception:
            if "\n" not in contents:
                raise ValueError(
                    f"Unable to parse the provided input in Genesis4 lattice "
                    f"format. It looks like this might have been a filename: "
                    f"{contents!r}"
                )
            raise
        return _LatticeTransformer(filename).transform(tree)

    @classmethod
    def from_file(cls, filename: AnyPath) -> Lattice:
        """
        Load a lattice file from disk.

        Parameters
        ----------
        filename : AnyPath
            The filename to load.

        Returns
        -------
        Lattice
        """
        with open(filename) as fp:
            contents = fp.read()
        return cls.from_contents(contents, filename=filename)

    def to_file(
        self,
        filename: AnyPath,
    ) -> None:
        """
        Write the lattice input file, in Genesis format, to ``filename``.

        Parameters
        ----------
        filename : str or pathlib.Path
        """
        main_config = self.to_genesis()
        with open(filename, "wt") as fp:
            print(main_config, file=fp)

        logger.debug(
            "Wrote lattice to %s:\n%s",
            main_config,
            filename,
        )


class ProfileArray(NameList):
    r"""
    ProfileArray is a lume-genesis convenience class for generating
    ``profile_file`` namelists.

    Attributes
    ----------
    x_label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    xdata : list of float or np.ndarray
        The `s`-position for the look-up table.
    ydata : list of float or np.ndarray
        The function values of the look-up table.
    isTime : bool, default=False
        If true the `s`-position is a time variable and therefore multiplied with the
        speed of light `c` to get the position in meters.
    reverse : bool, default=False
        if true the order in the look-up table is reverse. This is sometimes needed
        because time and spatial coordinates differ sometimes by a minus sign.
    filename : str, optional
        By default, this is a randomly-generated filename that lume-genesis
        manages for you.  If desirable, you may set a fixed filename relative
        to the main input file.  Path delimiters (such as ``/``) are not
        allowed.
    x_label : str, optional
        The X label (key) to use for the saved data.
    y_label : str, optional
        The Y label (key) to use for the saved data.
    """

    type: Literal["ProfileArray"] = "ProfileArray"
    label: str
    xdata: NDArray
    ydata: NDArray
    isTime: bool = False
    reverse: bool = False
    autoassign: bool = False
    filename: str = ""
    x_label: str = "x"
    y_label: str = "y"

    def write(self, base_path: AnyPath) -> pathlib.Path:
        if not self.filename:
            self.filename = util.get_temporary_filename(
                prefix=type(self).__name__, extension=".h5"
            )

        if "/" in self.filename:
            raise ValueError(
                f"Filename is not allowed to contain the path separator "
                f"forward slash (/).  Genesis 4 interprets these as part of "
                f"the HDF group. "
                f"Got: {self.filename!r}"
            )
        path = pathlib.Path(base_path) / self.filename
        with h5py.File(path, "w") as fp:
            # for key, value in self.hdf_data.items():
            #     fp[key] = value
            fp.update(self.get_hdf_data())
        logger.info("Saved %s to %s", self.label, path)
        return path

    def get_hdf_data(self) -> Dict[str, np.ndarray]:
        """Get all HDF5 data to be written for Genesis 4."""
        return {
            self.x_label: self.xdata,
            self.y_label: self.ydata,
        }

    def to_profile_file(self) -> ProfileFile:
        """Convert this ProfileArray into a 'profile_file' namelist for Genesis 4."""
        return ProfileFile(
            label=self.label,
            xdata=f"{self.filename}/{self.x_label}",
            ydata=f"{self.filename}/{self.y_label}",
            isTime=self.isTime,
            reverse=self.reverse,
            autoassign=self.autoassign,
        )

    def to_genesis(self) -> str:
        return self.to_profile_file().to_genesis()


class InitialParticles(NameList, arbitrary_types_allowed=True):
    r"""
    This class is a lume-genesis convenience class for generating
    ``importdistribution`` namelists from OpenPMD-beamphysics `ParticleGroup`
    instances.

    Three methods are supported for using `InitialParticles`:

    * Passing a `filename` of an existing particle file in the OpenPMD
      BeamPhysics standard.
    * Passing a `data` dictionary of all particle data (see the `data`
      parameter or the `ParticleData` type for details).
    * Passing an existing `ParticleGroup` instance as `particles`.  Note that
      this is equivalent to passing `data=particles.data` as `ParticleGroup`
      does not store source filename information.

    Attributes
    ----------
    filename : str or pathlib.Path
        If ``data`` is not specified, ``filename`` is assumed to be a
        pre-existing particle file that follows the OpenPMD BeamPhysics
        standard or the Genesis standard.
        If ``data`` is specified, particle data will be written to ``filename``
        when Genesis is launched.
    data : ParticleData
        The following keys are required:
        * `x`, `y`, `z` are np.ndarray in units of [m]
        * `px`, `py`, `pz` are np.ndarray momenta in units of [eV/c]
        * `t` is a np.ndarray of time in [s]
        * `status` is a status coordinate np.ndarray
        * `weight` is the macro-charge weight in [C], used for all statistical
        calculations.
        * `species` is a proper species name: `'electron'`, etc.
        The following keys are optional:
        * `id` is an optional np.ndarray of unique IDs
    temporary_filename : str
        By default, this is a randomly-generated filename that lume-genesis
        manages for you.  If desirable, you may set a fixed filename relative
        to the main input file.  Path delimiters (such as ``/``) are not
        allowed.
    """

    type: Literal["InitialParticles"] = "InitialParticles"
    data: Optional[ParticleData] = None
    filename: Optional[AnyPath] = pydantic.Field(init_var=True, default=None)
    particles: ParticleGroup = pydantic.Field(exclude=True, default=None)
    import_distribution: ImportDistribution = pydantic.Field(
        default_factory=ImportDistribution
    )
    temporary_filename: Optional[str] = None

    def model_post_init(self, context) -> None:
        workdir = pathlib.Path(".")
        if context and isinstance(context, dict):
            workdir = context.get("workdir", pathlib.Path("."))

        if self.filename is not None:
            self.particles = load_particle_group(workdir / self.filename)
            self.data = self.particles.data
            return

        if self.particles is not None:
            self.data = self.particles.data

        if self.data is None:
            raise ValueError(
                "Either `filename` or `data` must be specified for " "InitialParticles."
            )
        self.particles = ParticleGroup(data=self.data)

    @property
    def slen(self) -> float:
        """
        Length of the time window in meters.

        Note that for parallel jobs this might be adjusted towards larger
        values.

        This can be used to update the Time namelist with information
        from this initial particle distribution.
        """
        return max(
            c_light * self.particles.t.ptp(),
            self.particles.z.ptp(),
        )

    def _update_import_distribution(self) -> None:
        if not self.temporary_filename:
            self.temporary_filename = util.get_temporary_filename(
                prefix=type(self).__name__, extension=".h5"
            )

        self.import_distribution.file = str(self.temporary_filename)
        self.import_distribution.charge = self.particles.charge

    def write(self, base_path: AnyPath) -> pathlib.Path:
        """
        Write the particles to disk for usage with Genesis 4.

        Lume-genesis will assign a filename using this base path. Except for
        expert-level usage, you should not need to configure the specific
        filename as it is intended to be transparent to the user.

        Parameters
        ----------
        base_path : AnyPath
            The directory to write to.

        Returns
        -------
        pathlib.Path
        """
        self._update_import_distribution()
        if "/" in str(self.temporary_filename):
            raise ValueError(
                f"Filename is not allowed to contain the path separator "
                f"forward slash (/).  Genesis 4 interprets these as part of "
                f"the HDF group. "
                f"temporary_filename={self.temporary_filename!r}"
            )

        path = pathlib.Path(base_path) / self.temporary_filename
        self.particles.write_genesis4_distribution(str(path), verbose=True)
        logger.info("Saved particles to %s", path)
        return path

    def to_genesis(self) -> str:
        self._update_import_distribution()
        return self.import_distribution.to_genesis()


class MainInput(BaseModel):
    """
    A Genesis 4 main input configuration file.

    Attributes
    ----------
    namelists : list of NameList
        Elements contained in the lattice.
    filename : pathlib.Path or None
        The filename from which this was loaded.
    """

    namelists: List[AnyNameList] = pydantic.Field(default_factory=list)
    filename: Optional[pathlib.Path] = None

    def to_genesis(self) -> str:
        return "\n\n".join(namelist.to_genesis() for namelist in self.namelists)

    def _repr_table_data_(self):
        return {
            "obj": {f"{idx}": obj for idx, obj in enumerate(self.namelists)},
            "annotations": None,
            "descriptions": None,
        }

    def _repr_html_(self) -> str:
        repr_ = self.to_string("repr")
        return f"<pre>{repr_}</pre>"

    def __str__(self) -> str:
        return self.to_string("repr")

    @property
    def by_namelist(self) -> Dict[Type[T_NameList], List[T_NameList]]:
        """Get namelists organized by their class."""
        by_namelist = {}
        for namelist in self.namelists:
            by_namelist.setdefault(type(namelist), [])
            by_namelist[type(namelist)].append(namelist)
        return by_namelist

    @property
    def setup(self) -> Setup:
        """Get the required setup namelist."""
        setups = self.by_namelist.get(Setup, [])
        if len(setups) == 0:
            raise ValueError("Setup is not defined in the input.")
        if len(setups) > 1:
            raise ValueError("Multiple setup namelists were defined in the input.")
        return setups[0]

    def to_dicts(
        self, exclude_defaults: bool = True, by_alias: bool = True, **kwargs
    ) -> List[Dict]:
        """Serialize this main input to a list of dictionaries."""
        return [
            {
                "type": namelist.model_fields["type"].default,
                **namelist.model_dump(
                    exclude_defaults=exclude_defaults, by_alias=by_alias, **kwargs
                ),
            }
            for namelist in self.namelists
        ]

    @classmethod
    def from_dicts(
        cls, contents: Sequence[Dict], filename: Optional[pathlib.Path] = None
    ) -> MainInput:
        """
        Load main input from a list of serialized dictionaries.

        Parameters
        ----------
        contents : sequence of dict
            The serialized contents of the main input file.

        Returns
        -------
        MainInput
        """
        adapter = pydantic.TypeAdapter(AnyNameList)
        return cls(
            namelists=[adapter.validate_python(dct) for dct in contents],
            filename=filename,
        )

    @classmethod
    def from_contents(
        cls, contents: str, filename: Optional[AnyPath] = None
    ) -> MainInput:
        """
        Load main input from its file contents.

        Parameters
        ----------
        contents : str
            The contents of the main input file.
        filename : AnyPath or None, optional
            The filename, if known.

        Returns
        -------
        MainInput
        """
        parser = new_main_input_parser()
        filename = filename or "unknown"
        try:
            tree = parser.parse(contents)
        except Exception:
            if "\n" not in contents:
                raise ValueError(
                    f"Unable to parse the provided input in Genesis4 main input "
                    f"format. It looks like this might have been a filename: "
                    f"{contents!r}"
                )
            raise
        return _MainInputTransformer(filename).transform(tree)

    @classmethod
    def from_file(cls, filename: AnyPath) -> MainInput:
        """
        Load a main input file from disk.

        Parameters
        ----------
        filename : AnyPath
            The filename to load.

        Returns
        -------
        MainInput
        """
        with open(filename) as fp:
            contents = fp.read()
        return cls.from_contents(contents, filename=filename)

    def to_file(
        self,
        filename: AnyPath,
    ) -> None:
        """
        Write the main input file, in Genesis format, to ``filename``.

        Parameters
        ----------
        filename : str or pathlib.Path
        """
        main_config = self.to_genesis()
        with open(filename, "wt") as fp:
            print(main_config, file=fp)

        logger.debug(
            "Wrote main config to %s:\n%s",
            main_config,
            filename,
        )

    def write_files(
        self,
        workdir: AnyPath,
        main_filename: str = "genesis4.in",
        source_path: AnyPath = pathlib.Path(),
        rename: bool = True,
    ) -> List[pathlib.Path]:
        """
        Write the main input file, arrays and other necessary files to run
        Genesis to ``workdir``.

        Parameters
        ----------
        workdir : pathlib.Path or str
            The work directory where Genesis is to be run.
        main_filename : str, default = "genesis4.in"
            Filename to use for the main input file.
        source_path : pathlib.Path or str, optional
            The source directory, where any referenced HDF5 files will be
            found.  Defaults to the current directory.
        rename : bool, optional
            Adjust temporary filenames of HDF5 files, replacing random
            characters with sensible namelist-prefixed names.

        Returns
        -------
        List[pathlib.Path]
            The additional filenames that were written.
        """
        workdir = pathlib.Path(workdir).resolve()
        source_path = pathlib.Path(source_path).resolve()
        if not workdir.exists():
            raise ValueError(f"The configured work directory {workdir} does not exist")
        if not workdir.is_dir():
            raise ValueError(
                f"The configured work directory {workdir} is not a directory"
            )

        for namelist, filename in self._get_files_to_symlink():
            source_file = source_path / filename
            if not source_file.exists():
                raise FileNotFoundError(f"{source_file} (referenced in {namelist})")

        paths = []
        # Write out arrays to temporary HDF5 files so the user doesn't have to:
        for cls in (InitialParticles,):
            for idx, namelist in enumerate(self.by_namelist.get(cls, [])):
                if not namelist.filename and namelist.data:
                    namelist.temporary_filename = f"{cls.__name__}_{idx}.h5"
                paths.append(namelist.write(workdir))

        for cls in (ProfileArray,):
            for idx, namelist in enumerate(self.by_namelist.get(cls, [])):
                if rename or not namelist.filename:
                    namelist.filename = f"{cls.__name__}_{idx}.h5"
                paths.append(namelist.write(workdir))

        # Symlink user-referenced pre-existing HDF5 files:
        for _, filename in self._get_files_to_symlink():
            source_file = source_path / filename
            symlink = workdir / filename
            _symlink_or_copy(symlink=symlink, file=source_file)

            paths.append(symlink)

        # Write the main input file last, as temporary filenames may have
        # changed above.
        self.to_file(workdir / main_filename)
        paths.append(workdir / main_filename)
        return paths

    def _get_files_to_symlink(self) -> Generator[Tuple[AnyNameList, str], None, None]:
        for namelist in self.namelists:
            for attr in ("xdata", "ydata", "file"):
                file = getattr(namelist, attr, None)
                if file is None or isinstance(file, np.ndarray):
                    continue
                file = _split_file(namelist, attr, file)
                if not file:
                    continue
                yield namelist, file

    def set_particles(
        self, particle_group: ParticleGroup, update_slen: bool = True
    ) -> InitialParticles:
        """
        Set initial paticles using an OpenPMD-beamphysics ParticleGroup.

        `main_input.initial_particles = ParticleGroup()` is a shortcut
        for this method.

        Parameters
        ----------
        particle_group : ParticleGroup
        update_slen : bool, default=True
            Update slen
        """
        for particle in self.by_namelist.get(InitialParticles, []):
            logger.warning("Replacing previous InitialParticles instance")
            self.namelists.pop(particle)

        initial_particles = InitialParticles(particles=particle_group)
        self._insert_initial_particles(initial_particles, update_slen=update_slen)
        return initial_particles

    def _insert_initial_particles(
        self,
        initial_particles: InitialParticles,
        update_slen: bool,
    ) -> int:
        if update_slen:
            for time_ in self.times:
                was = time_.slen
                time_.slen = initial_particles.slen
                logger.warning(
                    "Updating time namelist slen: %f (was %f)",
                    time_.slen,
                    was,
                )

        if self.tracks:
            insert_pos = self.namelists.index(self.tracks[0])
        elif self.writes:
            insert_pos = self.namelists.index(self.writes[0])
        elif self.times:
            insert_pos = self.namelists.index(self.times[0]) + 1
        else:
            logger.warning(
                "Unable to determine a spot to insert the InitialParticles; "
                "placing it at the end"
            )
            insert_pos = len(self.namelists)

        self.namelists.insert(insert_pos, initial_particles)
        return insert_pos

    @property
    def initial_particles(self) -> InitialParticles:
        return self._get_only_one(InitialParticles)

    @initial_particles.setter
    def initial_particles(self, value: Union[ParticleGroup, InitialParticles]) -> None:
        if isinstance(value, ParticleGroup):
            self.set_particles(value)
        else:
            self._insert_initial_particles(value, update_slen=True)

    @property
    def alter_setups(self) -> List[auto_main.AlterSetup]:
        return self.by_namelist.get(auto_main.AlterSetup, [])

    @property
    def lattices(self) -> List[auto_main.Lattice]:
        return self.by_namelist.get(auto_main.Lattice, [])

    @property
    def times(self) -> List[auto_main.Time]:
        return self.by_namelist.get(auto_main.Time, [])

    @property
    def profile_consts(self) -> List[auto_main.ProfileConst]:
        return self.by_namelist.get(auto_main.ProfileConst, [])

    @property
    def profile_gausses(self) -> List[auto_main.ProfileGauss]:
        return self.by_namelist.get(auto_main.ProfileGauss, [])

    @property
    def profile_steps(self) -> List[auto_main.ProfileStep]:
        return self.by_namelist.get(auto_main.ProfileStep, [])

    @property
    def profile_polynoms(self) -> List[auto_main.ProfilePolynom]:
        return self.by_namelist.get(auto_main.ProfilePolynom, [])

    @property
    def profile_files(self) -> List[auto_main.ProfileFile]:
        return self.by_namelist.get(auto_main.ProfileFile, [])

    @property
    def sequence_consts(self) -> List[auto_main.SequenceConst]:
        return self.by_namelist.get(auto_main.SequenceConst, [])

    @property
    def sequence_polynoms(self) -> List[auto_main.SequencePolynom]:
        return self.by_namelist.get(auto_main.SequencePolynom, [])

    @property
    def sequence_powers(self) -> List[auto_main.SequencePower]:
        return self.by_namelist.get(auto_main.SequencePower, [])

    @property
    def sequence_randoms(self) -> List[auto_main.SequenceRandom]:
        return self.by_namelist.get(auto_main.SequenceRandom, [])

    @property
    def beams(self) -> List[auto_main.Beam]:
        return self.by_namelist.get(auto_main.Beam, [])

    @property
    def fields(self) -> List[auto_main.Field]:
        return self.by_namelist.get(auto_main.Field, [])

    @property
    def import_distributions(self) -> List[auto_main.ImportDistribution]:
        return self.by_namelist.get(auto_main.ImportDistribution, [])

    @property
    def import_beams(self) -> List[auto_main.ImportBeam]:
        return self.by_namelist.get(auto_main.ImportBeam, [])

    @property
    def import_fields(self) -> List[auto_main.ImportField]:
        return self.by_namelist.get(auto_main.ImportField, [])

    @property
    def import_transformations(self) -> List[auto_main.ImportTransformation]:
        return self.by_namelist.get(auto_main.ImportTransformation, [])

    @property
    def efields(self) -> List[auto_main.Efield]:
        return self.by_namelist.get(auto_main.Efield, [])

    @property
    def sponrads(self) -> List[auto_main.Sponrad]:
        return self.by_namelist.get(auto_main.Sponrad, [])

    @property
    def wakes(self) -> List[auto_main.Wake]:
        return self.by_namelist.get(auto_main.Wake, [])

    @property
    def writes(self) -> List[auto_main.Write]:
        return self.by_namelist.get(auto_main.Write, [])

    @property
    def tracks(self) -> List[auto_main.Track]:
        return self.by_namelist.get(auto_main.Track, [])

    @property
    def alter_fields(self) -> List[auto_main.AlterField]:
        return self.by_namelist.get(auto_main.AlterField, [])

    @property
    def profile_file_multis(self) -> List[auto_main.ProfileFileMulti]:
        return self.by_namelist.get(auto_main.ProfileFileMulti, [])

    @property
    def sequence_lists(self) -> List[auto_main.SequenceList]:
        return self.by_namelist.get(auto_main.SequenceList, [])

    @property
    def sequence_filelists(self) -> List[auto_main.SequenceFilelist]:
        return self.by_namelist.get(auto_main.SequenceFilelist, [])

    @property
    def profile_arrays(self) -> List[ProfileArray]:
        return self.by_namelist.get(ProfileArray, [])

    def _get_only_one(self, cls: Type[T_NameList]) -> T_NameList:
        items = self.by_namelist.get(cls, [])
        if len(items) == 0:
            raise ValueError(f"{cls.__name__} is not defined in the input.")
        if len(items) > 1:
            raise ValueError(
                f"Multiple {cls.__name__} namelists were defined in the input."
            )
        return items[0]

    @property
    def alter_setup(self) -> auto_main.AlterSetup:
        return self._get_only_one(auto_main.AlterSetup)

    @property
    def lattice(self) -> auto_main.Lattice:
        return self._get_only_one(auto_main.Lattice)

    @property
    def time(self) -> auto_main.Time:
        return self._get_only_one(auto_main.Time)

    @property
    def profile_const(self) -> auto_main.ProfileConst:
        return self._get_only_one(auto_main.ProfileConst)

    @property
    def profile_gauss(self) -> auto_main.ProfileGauss:
        return self._get_only_one(auto_main.ProfileGauss)

    @property
    def profile_step(self) -> auto_main.ProfileStep:
        return self._get_only_one(auto_main.ProfileStep)

    @property
    def profile_polynom(self) -> auto_main.ProfilePolynom:
        return self._get_only_one(auto_main.ProfilePolynom)

    @property
    def profile_file(self) -> auto_main.ProfileFile:
        return self._get_only_one(auto_main.ProfileFile)

    @property
    def sequence_const(self) -> auto_main.SequenceConst:
        return self._get_only_one(auto_main.SequenceConst)

    @property
    def sequence_polynom(self) -> auto_main.SequencePolynom:
        return self._get_only_one(auto_main.SequencePolynom)

    @property
    def sequence_power(self) -> auto_main.SequencePower:
        return self._get_only_one(auto_main.SequencePower)

    @property
    def sequence_random(self) -> auto_main.SequenceRandom:
        return self._get_only_one(auto_main.SequenceRandom)

    @property
    def beam(self) -> auto_main.Beam:
        return self._get_only_one(auto_main.Beam)

    @property
    def field(self) -> auto_main.Field:
        return self._get_only_one(auto_main.Field)

    @property
    def import_distribution(self) -> auto_main.ImportDistribution:
        return self._get_only_one(auto_main.ImportDistribution)

    @property
    def import_beam(self) -> auto_main.ImportBeam:
        return self._get_only_one(auto_main.ImportBeam)

    @property
    def import_field(self) -> auto_main.ImportField:
        return self._get_only_one(auto_main.ImportField)

    @property
    def import_transformation(self) -> auto_main.ImportTransformation:
        return self._get_only_one(auto_main.ImportTransformation)

    @property
    def efield(self) -> auto_main.Efield:
        return self._get_only_one(auto_main.Efield)

    @property
    def sponrad(self) -> auto_main.Sponrad:
        return self._get_only_one(auto_main.Sponrad)

    @property
    def wake(self) -> auto_main.Wake:
        return self._get_only_one(auto_main.Wake)

    @property
    def write(self) -> auto_main.Write:
        return self._get_only_one(auto_main.Write)

    @property
    def track(self) -> auto_main.Track:
        return self._get_only_one(auto_main.Track)

    @property
    def alter_field(self) -> auto_main.AlterField:
        return self._get_only_one(auto_main.AlterField)

    @property
    def profile_file_multi(self) -> auto_main.ProfileFileMulti:
        return self._get_only_one(auto_main.ProfileFileMulti)

    @property
    def sequence_list(self) -> auto_main.SequenceList:
        return self._get_only_one(auto_main.SequenceList)

    @property
    def sequence_filelist(self) -> auto_main.SequenceFilelist:
        return self._get_only_one(auto_main.SequenceFilelist)

    @property
    def profile_array(self) -> ProfileArray:
        return self._get_only_one(ProfileArray)


def _symlink_or_copy(symlink: pathlib.Path, file: pathlib.Path):
    if os.name == "nt":
        # With Windows 10, users need Administator Privileges or run on
        # Developer mode in order to be able to create symlinks.
        # Ref: https://docs.python.org/3/library/os.html#os.symlink
        return shutil.copy2(file, symlink)

    if symlink != file and not symlink.is_symlink():
        return symlink.symlink_to(file)


def _split_file(namelist: AnyNameList, attr: str, file: str) -> Optional[str]:
    """
    Get a filename from the namelist.

    Namelists such as ProfileFile store arrays in HDF5 files and reference
    them by way of a string in the form: ``"FILENAME/KEY"``.

    This limits Genesis4's ability to load files in absolute paths, as the
    delimiter ``/`` is used to separate the filename from the key.
    """
    if not isinstance(
        namelist,
        (
            ProfileFile,
            ProfileFileMulti,
            ImportDistribution,
            ImportBeam,
            ImportField,
            ImportTransformation,
            SequenceFilelist,
            # ProfileArray,
        ),
    ):
        return None
    if attr in ("xdata", "ydata"):
        # We can't handle paths here, although perhaps lume-genesis
        # could fix this for users... hmm.
        return file.split("/")[0]
    if attr in ("file",):
        return file
    raise NotImplementedError(attr)


class Genesis4Input(BaseModel):
    """
    All Genesis 4-related command input.

    Attributes
    ----------
    main : MainInput
        The main input. This contains all the namelists, starting with
        `&setup`.
    lattice : Lattice
        The lattice definition.
    beamline : str, optional
        Optional override for `beamline` in the setup namelist.
    lattice_name : str, optional
        Optional override for `lattice` in the setup namelist.
    seed : str, optional
        Optional override for `seed` in the setup namelist.
    output_path : Optional[AnyPath] = None
        Optional override for `rootname` in the setup namelist.
    source_path : Optional[AnyPath] = None
        When using Genesis 4-compatible input as strings, this is the directory
        where we expect to find other input HDF5 files.
    input_filename : str = "genesis4.in"
        The filename to use when writing the main input file. As a user, you
        should not need to worry about this as Genesis4Input will handle it for
        you.
    """

    main: MainInput
    lattice: Lattice
    beamline: Optional[str] = None
    lattice_name: Optional[str] = None
    seed: Optional[str] = None
    source_path: pathlib.Path = pathlib.Path(".")
    output_path: Optional[AnyPath] = None
    input_filename: str = "genesis4.in"

    def to_genesis(self) -> str:
        return "\n".join(
            (
                "# Main input",
                self.main.to_genesis(),
                "",
                "# Lattice",
                self.main.to_genesis(),
            )
        )

    def _repr_html_(self) -> str:
        repr_ = self.to_string("repr")
        return f"<pre>{repr_}</pre>"

    def __str__(self) -> str:
        return self.to_string("repr")

    @property
    def arguments(self) -> List[str]:
        """
        Get all of the command-line arguments for running Genesis 4.

        Returns
        -------
        list of str
            Individual arguments to pass to Genesis 4.
        """
        optional_args = []
        if self.beamline:
            optional_args.extend(["-b", self.beamline])
        if self.lattice_name:
            optional_args.extend(["-l", self.lattice_name])
        if self.seed is not None:
            optional_args.extend(["-s", self.seed])
        if self.output_path is not None:
            optional_args.extend(["-o", str(self.output_path)])
        return [
            *optional_args,
            "-l",
            str(self.lattice_filename),
            str(self.input_filename),
        ]

    @property
    def lattice_filename(self) -> str:
        """
        The filename of the lattice, determined from the Setup namelist.

        Defaults to "genesis.lat" if not previously set.
        """
        setup = self.main.setup
        if not setup.lattice:
            setup.lattice = "genesis.lat"
        return setup.lattice

    def write(
        self,
        workdir: AnyPath = pathlib.Path("."),
        write_run_script: bool = True,
        rename: bool = True,
    ) -> List[pathlib.Path]:
        """
        Write all input files for executing Genesis 4.

        Parameters
        ----------
        workdir : AnyPath
            The working directory for Genesis 4. This will be where all
            input and output files are written.
        rename : bool, optional
            Rename temporary HDF5 files according to their

        Returns
        -------
        List[pathlib.Path]
            Paths written.
        """
        path = pathlib.Path(workdir)
        path.mkdir(parents=True, mode=0o755, exist_ok=True)

        extra_paths = self.main.write_files(
            path,
            main_filename=self.input_filename,
            source_path=self.source_path,
        )
        lattice_path = path / self.lattice_filename
        self.lattice.to_file(filename=lattice_path)
        return [path / self.input_filename, lattice_path, *extra_paths]

    def write_run_script(
        self,
        path: pathlib.Path,
        command_prefix: str = "genesis4",
    ) -> None:
        with open(path, mode="wt") as fp:
            print(shlex.join(shlex.split(command_prefix) + self.arguments), file=fp)
        lume_tools.make_executable(str(path))

    @contextmanager
    def write_context(
        self, workdir: AnyPath
    ) -> Generator[List[pathlib.Path], None, None]:
        """
        Write all input files for executing Genesis 4.

        This is a context manager. When the context manager exits, all input
        files will be cleaned up (i.e., deleted from disk).

        Parameters
        ----------
        workdir : AnyPath
            The working directory for Genesis 4. This will be where all
            input and output files are written.

        Yields
        ------
        List[pathlib.Path]
            Paths written.
        """
        paths = self.write(workdir)
        yield paths
        for path in paths:
            path.unlink(missing_ok=True)

    @classmethod
    def from_main_input(
        cls,
        main: MainInput,
        lattice: Union[Lattice, str, pathlib.Path] = "",
        *,
        source_path: pathlib.Path = pathlib.Path("."),
    ) -> Genesis4Input:
        """
        Work with a lume-genesis MainInput and potentially an external
        lattice file or instance.

        If the input refers to files that already exist on disk, ensures
        that `source_path` is set correctly.
        """
        if isinstance(lattice, Lattice):
            return cls(
                main=main,
                lattice=lattice,
                source_path=source_path,
            )

        if lattice:
            lattice_path, lattice = tools.read_if_path(lattice)
            if lattice_path is not None:
                try:
                    setup = main.setup
                except ValueError:
                    # No setup yet; skip for now
                    pass
                else:
                    main.setup.lattice = lattice_path.name
            lattice = Lattice.from_contents(lattice, filename=lattice_path)
        else:
            logger.debug("Lattice not specified; determining from main input")
            setup = None
            try:
                setup = main.setup
                assert setup is not None
                # Use the lattice filename from main input's setup:
                with open(source_path / setup.lattice) as fp:
                    lattice = fp.read()
            except Exception:
                if setup is not None:
                    logger.exception(
                        "Lattice not specified and unable to determine it from the "
                        "main input's setup. Setup.lattice=%s Lattice file should "
                        "be located here: %s",
                        setup.lattice,
                        source_path / setup.lattice,
                    )
                raise
            lattice = Lattice.from_contents(
                lattice, filename=source_path / setup.lattice
            )

        return cls(
            main=main,
            lattice=lattice,
            source_path=source_path,
        )

    @classmethod
    def from_strings(
        cls,
        main: str,
        lattice: str = "",
        *,
        source_path: pathlib.Path = pathlib.Path("."),
        input_filename: Optional[pathlib.Path] = None,
        lattice_filename: Optional[pathlib.Path] = None,
    ) -> Genesis4Input:
        """
        Work directly with Genesis 4-compatible inputs.

        If unspecified, `lattice` will be determined from the `main` input
        settings.

        If the input refers to files that already exist on disk, ensures
        that `source_path` is set correctly.
        """
        main_config = MainInput.from_contents(main, filename=input_filename)

        if not lattice:
            return cls.from_main_input(main_config, source_path=source_path)

        return cls(
            main=main_config,
            lattice=Lattice.from_contents(lattice, filename=lattice_filename),
            source_path=source_path,
        )

    def archive(self, h5: h5py.Group, key: str = "input") -> None:
        """
        Dump input data into the given HDF5 group.

        Parameters
        ----------
        h5 : h5py.Group
            The HDF5 file in which to write the information.
        key : str, default="input"
            The key to use when storing the data.
        """
        tools.store_in_hdf5_file(h5, self, key=key)

    @classmethod
    def from_archive(cls, h5: h5py.Group, key: str = "input") -> Genesis4Input:
        """
        Loads input from archived h5 file.

        Parameters
        ----------
        h5 : str or h5py.File
            The filename or handle on h5py.File from which to load data.
        key : str, default="input"
            The key to use when restoring the data.
        """
        loaded = tools.restore_from_hdf5_file(h5, key=key)
        if not isinstance(loaded, Genesis4Input):
            raise ValueError(
                f"Loaded {loaded.__class__.__name__} instead of a "
                f"Genesis4Input instance.  Is key={key} correct?"
            )
        return loaded


def new_parser(filename: AnyPath, **kwargs) -> lark.Lark:
    """
    Get a new parser for one of the packaged grammars.

    Parameters
    ----------
    filename : str
        The packaged grammar filename.
    **kwargs :
        See :class:`lark.lark.LarkOptions`.
    """
    return lark.Lark.open_from_package(
        "genesis",
        str(filename),
        parser="lalr",
        maybe_placeholders=True,
        propagate_positions=True,
        **kwargs,
    )


def new_lattice_parser(**kwargs) -> lark.Lark:
    """
    Get a new parser for the packaged Lattice input grammar.

    Parameters
    ----------
    **kwargs :
        See :class:`lark.lark.LarkOptions`.
    """
    return new_parser(LATTICE_GRAMMAR, **kwargs)


def new_main_input_parser(**kwargs) -> lark.Lark:
    """
    Get a new parser for the packaged main input file grammar.

    Parameters
    ----------
    **kwargs :
        See :class:`lark.lark.LarkOptions`.
    """
    return new_parser(MAIN_INPUT_GRAMMAR, **kwargs)


def check_allows_reference(field: pydantic.fields.FieldInfo) -> bool:
    """Check if a field allows for a Reference type."""
    # A lazy method rather than full inspection of the annotated type. This
    # should work well enough assuming our type hints don't become extremely
    # complicated.
    return "Reference" in str(field.annotation)


def get_primary_type(field: pydantic.fields.FieldInfo) -> type:
    def is_model(typ):
        return isclass(typ) and issubclass(typ, pydantic.BaseModel)

    def check_type(typ: type) -> type:
        if is_model(typ):
            return typ
        if typ in {float, int, bool, str}:
            return typ
        if typing.get_origin(typ) in union_types:
            for subtype in typing.get_args(typ):
                if is_model(subtype):
                    if subtype is Reference:
                        continue
                    return subtype
                # TODO: throwing away anything beyond a union of 2
                return check_type(subtype)
        raise TypeError(f"Unhandled type: {typ}")

    assert field.annotation is not None
    return check_type(field.annotation)


def _fix_parameters(
    cls: Union[Type[BeamlineElement], Type[NameList]],
    params: Dict[str, lark.Token],
) -> Tuple[Dict[str, ValueType], Dict[str, str]]:
    """
    Fix parameters to beamline elements when transforming with
    :class:``_LatticeTransformer`.

    Parameters
    ----------
    cls : Type[BeamlineElement]
        The dataclass associated with the beamline element.  This is used to
        determine the attribute name and data type associated with the
        parameter.
    params : Dict[str, lark.Token]
        Parameter name map to lark Token value.

    Returns
    -------
    Dict[str, ValueType]
        Arguments for Pydantic model validation.
    Dict[str, str]
        Unexpected arguments for the dataclass; unsure what to do with them.
    """
    kwargs: Dict[str, ValueType] = {}
    extra: Dict[str, str] = {}
    fields = {
        field.serialization_alias: field
        for field in cls.model_fields.values()
        if field.serialization_alias
    }
    fields.update(
        {field.alias: field for field in cls.model_fields.values() if field.alias}
    )
    fields.update(cls.model_fields)

    for name, value in params.items():
        field = fields[name]
        dtype = field.annotation
        allow_reference = check_allows_reference(field)
        dtype = get_primary_type(field)
        string_value = str(value).strip()
        if dtype is None:
            extra[name] = string_value
        elif value.startswith("@") and allow_reference:
            kwargs[name] = Reference(string_value[1:].strip())
        elif dtype is int:
            try:
                kwargs[name] = int(value)
            except ValueError:
                # These may be references, let pydantic deal with them
                kwargs[name] = value
        elif dtype is float:
            try:
                kwargs[name] = float(value)
            except ValueError:
                # These may be references, let pydantic deal with them
                kwargs[name] = value
        elif dtype is bool:
            kwargs[name] = string_value.lower() in ("true", "t", "1")
        elif dtype is str:
            kwargs[name] = string_value
        else:
            raise RuntimeError(f"Unexpected type annotation hit for {name}: {dtype}")
    return kwargs, extra


class _LatticeTransformer(lark.visitors.Transformer_InPlaceRecursive):
    """
    Grammar transformer which takes lark objects and makes a :class:`Lattice`.

    Attributes
    ----------
    _filename : str
        Filename source of the input.
    """

    _filename: Optional[pathlib.Path]

    def __init__(self, filename: AnyPath) -> None:
        super().__init__()
        self._filename = pathlib.Path(filename)

        # This maps, e.g., "setup" to the Setup dataclass
        self.type_name_to_class = {
            cls.model_fields["type"].default: cls
            for cls in BeamlineElement.__subclasses__()
        }
        # Per the Genesis documents, only the first 4 characters are compared:
        self.partial_type_name_to_class = {
            name[:4].upper(): cls for name, cls in self.type_name_to_class.items()
        }

    @lark.v_args(inline=True)
    def line(
        self,
        label: lark.Token,
        _: lark.Token,  # line
        element_list: List[LineItem],
    ) -> Tuple[str, Line]:
        return str(label), Line(elements=element_list)

    @lark.v_args(inline=True)
    def parameter_set(
        self,
        parameter: lark.Token,
        value: lark.Token,
    ) -> Tuple[str, lark.Token]:
        return str(parameter), value

    def parameter_list(
        self, sets: List[Tuple[str, ValueType]]
    ) -> List[Tuple[str, ValueType]]:
        return list(sets)

    @lark.v_args(inline=True)
    def beamline_element(
        self,
        label: lark.Token,
        type_: lark.Token,
        parameter_list: Optional[List[Tuple[str, lark.Token]]],
    ) -> Tuple[str, BeamlineElement]:
        cls = self.partial_type_name_to_class[type_.upper()[:4]]
        parameters, unknown = _fix_parameters(cls, dict(parameter_list or []))
        if unknown:
            raise ValueError(
                f"Beamline element {label} received unexpected parameter(s): "
                f"{unknown}"
            )
        parameters["type"] = cls.model_fields["type"].default.lower()
        element = cls.model_validate(parameters)
        return str(label), element

    @lark.v_args(inline=True)
    def duplicate_item(
        self,
        count: lark.Token,
        label: lark.Token,
    ) -> DuplicatedLineItem:
        return DuplicatedLineItem(
            label=str(label),
            count=int(count),
        )

    @lark.v_args(inline=True)
    def positioned_item(
        self,
        label: lark.Token,
        position: lark.Token,
    ) -> PositionedLineItem:
        return PositionedLineItem(
            label=str(label),
            position=float(position),
        )

    @lark.v_args(inline=True)
    def line_item(
        self, item: Union[lark.Token, DuplicatedLineItem, PositionedLineItem]
    ) -> Union[str, DuplicatedLineItem, PositionedLineItem]:
        if isinstance(item, lark.Token):
            return str(item)
        return item

    def element_list(
        self, items: List[Union[lark.Token, DuplicatedLineItem, PositionedLineItem]]
    ) -> List[Union[lark.Token, DuplicatedLineItem, PositionedLineItem]]:
        return items

    def lattice(self, elements: List[Tuple[str, AnyBeamlineElement]]) -> Lattice:
        return Lattice(
            elements=dict(elements),
            filename=self._filename,
        )


class _MainInputTransformer(lark.visitors.Transformer_InPlaceRecursive):
    """
    Grammar transformer which takes lark objects and makes a :class:`MainInput`.

    Attributes
    ----------
    _filename : str
        Filename source of the input.
    """

    _filename: Optional[pathlib.Path]

    def __init__(self, filename: AnyPath) -> None:
        super().__init__()
        self._filename = pathlib.Path(filename)

        # This maps, e.g., "setup" to the Setup dataclass
        self.type_name_to_class = {
            cls.model_fields["type"].default: cls for cls in NameList.__subclasses__()
        }

    @lark.v_args(inline=True)
    def parameter_set(
        self,
        parameter: lark.Token,
        value: lark.Token,
    ) -> Tuple[str, lark.Token]:
        return (str(parameter), value)

    def parameter_list(
        self, sets: List[Tuple[str, ValueType]]
    ) -> List[Tuple[str, ValueType]]:
        return list(sets)

    @lark.v_args(inline=True)
    def namelist(
        self,
        name: lark.Token,
        parameter_list: List[Tuple[str, lark.Token]],
        _: lark.Token,  # end
    ) -> NameList:
        cls = self.type_name_to_class[name]
        parameters, unknown = _fix_parameters(cls, dict(parameter_list))
        if unknown:
            raise ValueError(
                f"Namelist {name} received unexpected parameter(s): " f"{unknown}"
            )
        return cls(**parameters)

    @lark.v_args(inline=True)
    def main_input(self, *namelists: AnyNameList) -> MainInput:
        return MainInput(namelists=list(namelists), filename=self._filename)
