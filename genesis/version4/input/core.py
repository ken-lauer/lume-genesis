from __future__ import annotations

import copy
import logging
import os
import pathlib
import shlex
import shutil
import typing
from contextlib import contextmanager
from inspect import isclass
from typing import (
    Any,
    Dict,
    Generator,
    List,
    NamedTuple,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
)

import h5py
import lark
import matplotlib
import matplotlib.axes
import matplotlib.pyplot as plt
import numpy as np
import pydantic
import pydantic.alias_generators
from lume import tools as lume_tools
from pmd_beamphysics import ParticleGroup
from pmd_beamphysics.units import nice_array
from pmd_beamphysics.units import c_light
from typing_extensions import override

from ... import tools
from ...errors import (
    MultipleNamelistsError,
    NamelistAccessError,
    NoSuchNamelistError,
    NotFlatError,
    RecursiveLineError,
)
from .. import archive as _archive
from ..field import FieldFile
from ..types import (
    AnyPath,
    BaseModel,
    BeamlineElement,
    NameList,
    NDArray,
    PydanticParticleGroup,
    Reference,
    ReprTableData,
    ValueType,
    union_types,
)
from . import _lattice as auto_lattice
from . import _main as auto_main
from . import util
from ._main import (
    ImportBeam,
    ImportDistribution,
    ImportField,
    ImportTransformation,
    ProfileFile,
    ProfileFileMulti,
    SequenceFilelist,
    Setup,
)

try:
    from typing import Literal
except ImportError:
    from typing_extensions import Literal


AnyNameList = Union[
    auto_main.AutogeneratedNameList,
    "ProfileArray",
]
AnyBeamlineElement = Union[
    auto_lattice.AutogeneratedBeamlineElement,
    "Line",
]


T_NameList = TypeVar("T_NameList", bound=NameList)
T_BeamlineElement = TypeVar("T_BeamlineElement", bound=BeamlineElement)

LineItem = Union[str, "DuplicatedLineItem", "PositionedLineItem", AnyBeamlineElement]

LATTICE_GRAMMAR = pathlib.Path("version4") / "input" / "lattice.lark"
MAIN_INPUT_GRAMMAR = pathlib.Path("version4") / "input" / "main_input.lark"

logger = logging.getLogger(__name__)


class ZElement(NamedTuple):
    """A tuple of a Z position and its corresponding beamline element."""

    zend: float
    element: AnyBeamlineElement


class ElementPlotSettings(NamedTuple):
    color: str
    width: float
    alpha: float = 1.0


plot_settings_by_element = {
    auto_lattice.Undulator: ElementPlotSettings(color="orange", width=0.2),
    auto_lattice.Drift: ElementPlotSettings(color="black", width=0.05, alpha=0.5),
    auto_lattice.Quadrupole: ElementPlotSettings(color="blue", width=0.1),
    auto_lattice.Corrector: ElementPlotSettings(color="green", width=0.3),
    auto_lattice.PhaseShifter: ElementPlotSettings(color="red", width=0.2),
    auto_lattice.Chicane: ElementPlotSettings(color="grey", width=0.4),
    auto_lattice.Marker: ElementPlotSettings(color="gray", width=0.2),
}


class DuplicatedLineItem(BaseModel):
    """
    A Genesis 4 lattice Line item which is at a certain position.

    This corresponds to Genesis 4 `"COUNT*LABEL"`.

    Attributes
    ----------
    label : str
        The name/label of the line item.
    count : int
        The number of times to repeat the line item.
    """

    label: str
    count: int

    @classmethod
    def from_string(cls, value: str) -> DuplicatedLineItem:
        count, label = value.split("*", 1)
        return cls(
            label=label.strip(),
            count=int(count),
        )

    def to_genesis(self) -> str:
        return str(self)

    @override
    def __str__(self) -> str:
        return f"{self.count}*{self.label}"


class PositionedLineItem(BaseModel):
    """
    A Genesis 4 lattice Line item which is at a certain position.

    This corresponds to Genesis 4 `"LABEL@POSITION"`.

    Attributes
    ----------
    label : str
        The name/label of the line item.
    position : float
        The position of the element.
    """

    label: str
    position: float

    @classmethod
    def from_string(cls, value: str) -> PositionedLineItem:
        label, position = value.split("@", 1)
        return cls(
            label=label.strip(),
            position=float(position.strip()),
        )

    def to_genesis(self) -> str:
        return str(self)

    @override
    def __str__(self) -> str:
        return f"{self.label}@{self.position}"


def _fix_line_item(line_item: LineItem) -> LineItem:
    """Make the appropriate dataclass for a serialized line item, if necessary."""
    if isinstance(line_item, (DuplicatedLineItem, PositionedLineItem)):
        return line_item
    if isinstance(line_item, BeamlineElement):
        return line_item
    if "@" in line_item:
        return PositionedLineItem.from_string(line_item)
    if "*" in line_item:
        return DuplicatedLineItem.from_string(line_item)
    return line_item


class Line(BeamlineElement):
    """
    A Genesis 4 beamline Line.

    Attributes
    ----------
    elements : list of LineItem
        Elements contained in the line.
    label : str, optional
        An optional label to attach to the line.
    """

    type: Literal["line"] = "line"
    elements: List[LineItem] = pydantic.Field(default_factory=list, kw_only=False)
    label: str = pydantic.Field(default="")

    @override
    def model_post_init(self, __context: Any) -> None:
        self.elements = [_fix_line_item(item) for item in self.elements]

    @property
    def names(self) -> List[str]:
        return [
            elem.label if isinstance(elem, BeamlineElement) else str(elem)
            for elem in self.elements
        ]

    @override
    def to_genesis(self) -> str:
        elements = ", ".join(self.names)
        return "".join(
            (
                self.label,
                ": LINE = {",
                elements,
                "};",
            )
        )

    @classmethod
    def from_labels(
        cls,
        elements: Dict[str, AnyBeamlineElement],
        *element_labels: str,
        label: str = "",
    ) -> Line:
        """
        Create a `Line` from labeled beamline elements.

        Parameters
        ----------
        elements : Dict[str, BeamlineElement]
            The element dictionary.
        *element_labels : str
            Labels of elements.  May be either a single label per argument or a
            whitespace-delimited string of labels.
        label : str
            Label name for the line.

        Returns
        -------
        Line
        """
        try:
            return cls(
                elements=[
                    elements[label]
                    for labels in element_labels
                    for label in labels.strip().split()
                ],
                label=label,
            )
        except KeyError as ex:
            raise ValueError(
                f"Label {ex} is not present in the beamline element dictionary. "
                f"The following are valid: {tuple(elements.keys())}"
            )


def lattice_elements_from_list(
    elements: Sequence[AnyBeamlineElement],
) -> Dict[str, AnyBeamlineElement]:
    """
    Make a label-to-lattice-element dictionary from a sequence of elements.

    Parameters
    ----------
    elements : Sequence[AnyBeamlineElement]

    Returns
    -------
    Dict[str, AnyBeamlineElement]
    """
    res = {}
    for idx, element in enumerate(elements):
        label = element.label
        if not label:
            raise ValueError(f"Element #{idx} does not have a label: ({element})")
        if label in res:
            raise ValueError(
                f"Element #{idx} has a duplicate label to another element. "
                f"Previous: {res[label]} "
                f"element[{idx}] = {element}"
            )
        res[label] = element
    return res


class Lattice(BaseModel):
    """
    A Genesis 4 beamline Lattice configuration.

    Attributes
    ----------
    elements : list of BeamlineElement or Line
        Elements contained in the lattice.
    filename : pathlib.Path or None
        The filename from which this lattice was loaded.
    """

    elements: Dict[str, AnyBeamlineElement] = pydantic.Field(
        default_factory=dict,
    )
    filename: Optional[pathlib.Path] = None

    def __init__(
        self,
        elements: Union[
            Dict[str, AnyBeamlineElement], List[AnyBeamlineElement], None
        ] = None,
        *,
        filename: Optional[pathlib.Path] = None,
    ) -> None:
        if elements is None:
            elements = {}
        if not isinstance(elements, dict):
            elements = lattice_elements_from_list(elements)
        super().__init__(elements=elements, filename=filename)

    def taper_custom(
        self,
        beamline: str,
        *,
        aw0: float,
        zstart: float,
        zend: float,
    ) -> List[ZElement]:
        """
        Get a list of undulators to perform a custom taper on.

        Only elements that fit within the range [zstart, zend] will be
        included.

        Parameters
        ----------
        beamline : str
            The beamline containing the undulators.
        aw0 : float
            The starting undulator strength.
        zstart : float
            The starting Z position, relative to the first element on the line.
        zend : float
            The ending Z position, relative to the first element on the line.

        Returns
        -------
        list of ZElement
            List of ZElement instances, which contain a normalized Z location
            (zstart=0.0, zend=1.0) and an Undulator element.
        """
        if not self.is_flat(beamline):
            raise NotFlatError(
                f"The beamline {beamline!r} is not flat: it contains reused "
                f"elements.  Before performing a taper operation, first flatten "
                f"the beamline with `.flatten_line()`"
            )

        assert zend > zstart

        undulators = self.by_z_location(beamline, limit_to=auto_lattice.Undulator)
        norm_z = []
        for zelem in undulators:
            und = zelem.element
            assert isinstance(und, auto_lattice.Undulator)
            if zstart <= zelem.zend <= zend:
                norm_z.append(
                    ZElement(
                        zend=(zelem.zend - zstart) / (zend - zstart),
                        element=und,
                    )
                )
            else:
                und.aw = aw0

        return norm_z

    def taper_array(
        self,
        beamline: str,
        aws: Sequence[float],
    ) -> None:
        if not self.is_flat(beamline):
            raise NotFlatError(
                f"The beamline {beamline!r} is not flat: it contains reused "
                f"elements.  Before performing a taper operation, first flatten "
                f"the beamline with `.flatten_line()`"
            )

        undulators = self.by_z_location(beamline, limit_to=auto_lattice.Undulator)
        aws = list(aws)
        if len(aws) != len(undulators):
            raise ValueError(
                f"The number of undulators ({len(undulators)}) is not equal to "
                f"the number of aw parameters provided ({len(aws)})"
            )
        for aw, (_z, und) in zip(aws, undulators):
            und = typing.cast(auto_lattice.Undulator, und)
            und.aw = aw

    def taper_linear(
        self,
        beamline: str,
        *,
        aw0: float,
        zstart: float,
        zend: float,
        taper_start: float,
        taper_end: float,
    ) -> List[float]:
        """
        Perform a linear taper on undulators in the given beamline.

        Only elements that fit within the range [zstart, zend] will be
        included.

        Parameters
        ----------
        beamline : str
            The beamline containing the undulators.
        aw0 : float
            The starting undulator strength.
        zstart : float
            The starting Z position, relative to the first element on the line.
        zend : float
            The ending Z position, relative to the first element on the line.
        taper_start : float
            The starting taper multiplier (applied to `aw0`) at `zstart`.
        taper_end : float
            The final taper multiplier (applied to `aw0`) at `zend`.

        Returns
        -------
        list of float
            List of undulator strengths.
        """
        # taper_custom will give normalized Z values for [zstart, zend] -> [0, 1]
        undulators = self.taper_custom(beamline, aw0=aw0, zstart=zstart, zend=zend)
        slope = aw0 * (taper_end - taper_start) / (1.0 - 0.0)  # / (zend - zstart)
        for norm_z, und in undulators:
            assert isinstance(und, auto_lattice.Undulator)
            und.aw = aw0 + slope * norm_z

        return [zelem.element.aw for zelem in undulators]

    def plot(
        self,
        beamline: str,
        *,
        show_labels: bool = True,
        show_legend: bool = True,
        show: bool = True,
    ):
        _, (ax1, ax2) = plt.subplots(nrows=2, ncols=1)

        ax1: matplotlib.axes.Axes
        ax2: matplotlib.axes.Axes
        self.plot_layout(beamline, ax=ax1, show=False, show_labels=show_labels)
        self.plot_strengths(
            beamline,
            ax=ax2,
            show=False,
            show_labels=show_labels,
            show_legend=show_legend,
        )
        for label in ax1.get_xticklabels() + ax1.get_yticklabels():
            label.set_visible(False)
        ax1.set_title("")
        ax1.set_xlabel("")
        ax2.set_title("")
        plt.suptitle(f"Beamline '{beamline}'")
        if show:
            plt.show()

    def plot_layout(
        self,
        beamline: str,
        *,
        ax: Optional[matplotlib.axes.Axes] = None,
        show_labels: bool = True,
        show: bool = True,
    ):
        elements = self.by_z_location(beamline)
        if ax is None:
            _, ax = plt.subplots()
        assert ax is not None
        default = ElementPlotSettings(color="black", width=0.2)
        for zend, elem in elements:
            settings = plot_settings_by_element.get(type(elem), default)
            if isinstance(elem, (auto_lattice.Drift, Line)):
                continue
            elif isinstance(elem, auto_lattice.Marker):
                zstart = zend
            else:
                zstart = zend - elem.L
                ax.fill_between(
                    (zstart, zend),
                    -settings.width,
                    settings.width,
                    color=settings.color,
                    label=elem.label,
                    alpha=settings.alpha,
                )

            zmid = (zend + zstart) / 2.0
            annotation = ax.annotate(
                elem.label,
                xy=(zmid, 0.0),
            )
            annotation.set_rotation(90)
            annotation.set_fontsize("x-small")

        ax.set_xlabel("$z$ (m)")
        ax.set_title(f"{beamline} Layout")
        if show:
            plt.show()

    def plot_strengths(
        self,
        beamline: str,
        *,
        ax: Optional[matplotlib.axes.Axes] = None,
        show_labels: bool = True,
        show_legend: bool = True,
        show: bool = True,
    ):
        """
        Plot the layout of the given beamline.

        Parameters
        ----------
        beamline : str
            The name of the beamline.
        ax : matplotlib.axes.Axes or None
            Plot on the given axis, or create a new one.
        show_labels : bool
            Show labels for each undulator.
        show : bool
            Show the plot.
        """
        elements = self.by_z_location(beamline)
        undulators = [
            (elem.zend, elem.element)
            for elem in elements
            if isinstance(elem.element, auto_lattice.Undulator)
        ]
        quads = [
            (elem.zend, elem.element)
            for elem in elements
            if isinstance(elem.element, auto_lattice.Quadrupole)
        ]
        if ax is None:
            _, ax = plt.subplots()
        assert ax is not None

        def nice_plot(
            ax: matplotlib.axes.Axes,
            zs: Sequence[float],
            values: Sequence[float],
            units: str,
            marker: str,
            color=None,
            label=None,
        ):
            y, _factor, prefix = nice_array(values)
            ylabel = f"{label} ({prefix}{units})"
            ax.set_ylabel(ylabel)
            ax.plot(
                zs,
                y,
                color=color,
                label=label,
                alpha=0.5,
                marker=marker,
                markersize=2.0,
            )
            return ax.fill_between(zs, y, color=color, label=label, alpha=0.15)

        lines = [
            nice_plot(
                ax,
                [z for z, _ in undulators],
                [und.aw for _, und in undulators],
                units="1",
                marker="o",
                label="$aw$",
                color="red",
            ),
            nice_plot(
                ax.twinx(),
                [z for z, _ in quads],
                [quad.k1 for _, quad in quads],
                units="$1/m^2$",
                marker="o",
                label="Quad $k$",
                color="blue",
            ),
        ]

        if show_legend:
            labels = [str(line.get_label() or "") for line in lines]
            ax.legend(lines, labels)

        if show_labels:
            for z, und in undulators:
                annotation = ax.annotate(
                    und.label,
                    xy=(z, 1.01 * und.aw),
                )
                annotation.set_rotation(90)
                annotation.set_fontsize("xx-small")

        ax.set_xlabel("$z$ (m)")
        ax.set_title(f"{beamline} Layout")
        if show:
            plt.show()

    def is_flat(self, beamline: str) -> bool:
        """Checks if the given `beamline` does not reuse elements."""
        names = self.inspect_line_by_name(beamline)
        return len(set(names)) == len(names)

    def inspect_line_by_name(self, beamline: str) -> List[str]:
        """
        Returns a list of all element names in the given beamline.

        This recursively inspects any LINEs inside the beamline.

        Returns
        -------
        list of str
            List of names.
        """
        self.fix_labels()
        stack = []

        def _inspect(name: str):
            if name in stack:
                raise RecursiveLineError(
                    f"Recursion of beamline elements in line {beamline} detected: {name}"
                )
            stack.append(name)
            element = self.elements[name]
            if isinstance(element, Line):
                for el in element.names:
                    yield from _inspect(el)
            elif isinstance(element, DuplicatedLineItem):
                for _ in range(element.count):
                    yield from _inspect(element.label)
            elif isinstance(element, PositionedLineItem):
                yield element.label
            else:
                yield element.label
            stack.pop(-1)

        return list(_inspect(beamline))

    def inspect_line(self, beamline: str) -> List[AnyBeamlineElement]:
        """
        Returns a list of all elements in the given beamline.

        This recursively inspects any LINEs inside the beamline.

        Returns
        -------
        list of BeamlineElement
            List of beamline element instances.
        """
        return [self.elements[el] for el in self.inspect_line_by_name(beamline)]

    def flatten_line(
        self,
        beamline: str,
        *,
        count: int,
        start: int = 0,
        format: str = "L{index}_{name}",
        in_place: bool = True,
        new_beamline: str = "",
    ):
        to_duplicate = self.inspect_line_by_name(beamline)
        new_elements = {}
        sections = []
        for index in range(start, start + count):
            section = []
            for name in to_duplicate:
                new_name = format.format(
                    name=name,
                    index=index,
                    start=start,
                    count=count,
                    beamline=beamline,
                )
                new_element = copy.deepcopy(self.elements[name])
                new_element.label = new_name
                new_elements[new_name] = new_element
                section.append(new_element)
            sections.append(section)

        if in_place:
            for name in to_duplicate:
                self.elements.pop(name)

        self.elements[new_beamline or beamline] = Line(elements=list(new_elements))
        self.elements.update(new_elements)
        return sections

    def by_z_location(
        self,
        beamline: str,
        limit_to: Union[
            Type[BeamlineElement],
            Tuple[Type[BeamlineElement], ...],
            None,
        ] = None,
    ) -> List[ZElement]:
        """
        Get all (flattened) beamline elements by Z location.

        Returns
        -------
        list of (zend, element)
            Each list item is a ZElement, a namedtuple which has `.zend` and
            `.element` that is also usable as a normal tuple.
        """
        z = 0.0
        by_z = []
        for el in self.inspect_line(beamline):
            if isinstance(
                el,
                (
                    auto_lattice.Drift,
                    auto_lattice.Quadrupole,
                    auto_lattice.Corrector,
                    auto_lattice.Chicane,
                    auto_lattice.PhaseShifter,
                    auto_lattice.Undulator,
                ),
            ):
                z += el.L
            elif isinstance(el, auto_lattice.Marker):
                ...
            else:
                assert not isinstance(el, Line), "Line should be expanded"
                raise NotImplementedError(type(el))

            if limit_to is None or isinstance(el, limit_to):
                by_z.append(ZElement(zend=z, element=el))

        return by_z

    @override
    def _repr_table_data_(self) -> ReprTableData:
        return {
            "obj": self.elements,
            "annotations": None,
            "descriptions": None,
        }

    @override
    def __str__(self) -> str:
        return self.to_string("repr")

    @override
    def _repr_html_(self) -> str:
        repr_ = self.to_string("repr")
        return f"<pre>{repr_}</pre>"

    def to_genesis(self) -> str:
        self.fix_labels()
        return "\n".join(element.to_genesis() for element in self.elements.values())

    def fix_labels(self) -> None:
        for label, element in self.elements.items():
            if element.label != label:
                if element.label:
                    logger.warning(
                        "Renaming beamline element in lattice from %s to %s",
                        element.label,
                        label,
                    )
                element.label = label

    @property
    def by_element(self) -> Dict[Type[T_BeamlineElement], List[T_BeamlineElement]]:
        """Get beamline elements organized by their class."""
        by_element = {}
        for element in self.elements.values():
            by_element.setdefault(type(element), [])
            by_element[type(element)].append(element)
        return by_element

    @property
    def undulators(self) -> List[auto_lattice.Undulator]:
        """List of all Undulator instances."""
        return self.by_element.get(auto_lattice.Undulator, [])

    @property
    def drifts(self) -> List[auto_lattice.Drift]:
        """List of all Drift instances."""
        return self.by_element.get(auto_lattice.Drift, [])

    @property
    def quadrupoles(self) -> List[auto_lattice.Quadrupole]:
        """List of all Quadrupole instances."""
        return self.by_element.get(auto_lattice.Quadrupole, [])

    @property
    def correctors(self) -> List[auto_lattice.Corrector]:
        """List of all Corrector instances."""
        return self.by_element.get(auto_lattice.Corrector, [])

    @property
    def chicanes(self) -> List[auto_lattice.Chicane]:
        """List of all Chicane instances."""
        return self.by_element.get(auto_lattice.Chicane, [])

    @property
    def phase_shifters(self) -> List[auto_lattice.PhaseShifter]:
        """List of all PhaseShifter instances."""
        return self.by_element.get(auto_lattice.PhaseShifter, [])

    @property
    def markers(self) -> List[auto_lattice.Marker]:
        """List of all Marker instances."""
        return self.by_element.get(auto_lattice.Marker, [])

    @property
    def lines(self) -> List[Line]:
        """List of all Line instances."""
        return self.by_element.get(Line, [])

    @override
    def model_dump(self, **kwargs: Any) -> Dict[str, Any]:
        """Serialize this lattice to a list of dictionaries."""
        self.fix_labels()
        return super().model_dump(**kwargs)

    @classmethod
    def from_contents(
        cls, contents: str, filename: Optional[AnyPath] = None
    ) -> Lattice:
        """
        Load a lattice from its file contents.

        Parameters
        ----------
        contents : str
            The contents of the lattice file.
        filename : AnyPath or None, optional
            The filename of the lattice, if known.

        Returns
        -------
        Lattice
        """
        parser = new_lattice_parser()
        filename = filename or "unknown"
        try:
            tree = parser.parse(contents)
        except Exception:
            if "\n" not in contents:
                raise ValueError(
                    f"Unable to parse the provided input in Genesis4 lattice "
                    f"format. It looks like this might have been a filename: "
                    f"{contents!r}"
                )
            raise
        return _LatticeTransformer(filename).transform(tree)

    @classmethod
    def from_file(cls, filename: AnyPath) -> Lattice:
        """
        Load a lattice file from disk.

        Parameters
        ----------
        filename : AnyPath
            The filename to load.

        Returns
        -------
        Lattice
        """
        with open(filename) as fp:
            contents = fp.read()
        return cls.from_contents(contents, filename=filename)

    def to_file(
        self,
        filename: AnyPath,
    ) -> None:
        """
        Write the lattice input file, in Genesis format, to ``filename``.

        Parameters
        ----------
        filename : str or pathlib.Path
        """
        main_config = self.to_genesis()
        with open(filename, "wt") as fp:
            print(main_config, file=fp)

        logger.debug(
            "Wrote lattice to %s:\n%s",
            main_config,
            filename,
        )


class ProfileArray(NameList):
    r"""
    ProfileArray is a lume-genesis convenience class for generating
    ``profile_file`` namelists.

    Attributes
    ----------
    x_label : str
        Name of the profile, which is used to refer to it in later calls of namelists
    xdata : list of float or np.ndarray
        The `s`-position for the look-up table.
    ydata : list of float or np.ndarray
        The function values of the look-up table.
    isTime : bool, default=False
        If true the `s`-position is a time variable and therefore multiplied with the
        speed of light `c` to get the position in meters.
    reverse : bool, default=False
        if true the order in the look-up table is reverse. This is sometimes needed
        because time and spatial coordinates differ sometimes by a minus sign.
    filename : str, optional
        By default, this is a randomly-generated filename that lume-genesis
        manages for you.  If desirable, you may set a fixed filename relative
        to the main input file.  Path delimiters (such as ``/``) are not
        allowed.
    x_label : str, optional
        The X label (key) to use for the saved data.
    y_label : str, optional
        The Y label (key) to use for the saved data.
    """

    type: Literal["ProfileArray"] = "ProfileArray"
    label: str
    xdata: NDArray
    ydata: NDArray
    isTime: bool = False
    reverse: bool = False
    autoassign: bool = False
    filename: str = ""
    x_label: str = "x"
    y_label: str = "y"

    def write(self, base_path: AnyPath) -> pathlib.Path:
        if not self.filename:
            self.filename = util.get_temporary_filename(
                prefix=type(self).__name__, extension=".h5"
            )

        if "/" in self.filename:
            raise ValueError(
                f"Filename is not allowed to contain the path separator "
                f"forward slash (/).  Genesis 4 interprets these as part of "
                f"the HDF group. "
                f"Got: {self.filename!r}"
            )
        path = pathlib.Path(base_path) / self.filename
        with h5py.File(path, "w") as fp:
            # for key, value in self.hdf_data.items():
            #     fp[key] = value
            fp.update(self.get_hdf_data())
        logger.info("Saved %s to %s", self.label, path)
        return path

    def get_hdf_data(self) -> Dict[str, np.ndarray]:
        """Get all HDF5 data to be written for Genesis 4."""
        return {
            self.x_label: self.xdata,
            self.y_label: self.ydata,
        }

    def to_profile_file(self) -> ProfileFile:
        """Convert this ProfileArray into a 'profile_file' namelist for Genesis 4."""
        return ProfileFile(
            label=self.label,
            xdata=f"{self.filename}/{self.x_label}",
            ydata=f"{self.filename}/{self.y_label}",
            isTime=self.isTime,
            reverse=self.reverse,
            autoassign=self.autoassign,
        )

    @override
    def to_genesis(self) -> str:
        return self.to_profile_file().to_genesis()


def get_particles_slen(particles: ParticleGroup) -> float:
    """
    Length of the time window in meters.

    Note that for parallel jobs this might be adjusted towards larger
    values.

    This can be used to update the Time namelist with information
    from this initial particle distribution.
    """
    return max(
        c_light * particles.t.ptp(),
        particles.z.ptp(),
    )


class MainInput(BaseModel):
    """
    A Genesis 4 main input configuration file.

    Attributes
    ----------
    namelists : list of NameList
        Elements contained in the lattice.
    filename : pathlib.Path or None
        The filename from which this was loaded.
    """

    namelists: List[AnyNameList]
    filename: Optional[pathlib.Path]

    def __init__(
        self,
        namelists: Optional[List[AnyNameList]] = None,
        *,
        filename: Optional[pathlib.Path] = None,
    ) -> None:
        if namelists is None:
            namelists = []
        super().__init__(namelists=namelists, filename=filename)

    def to_genesis(self) -> str:
        return "\n\n".join(namelist.to_genesis() for namelist in self.namelists)

    @override
    def _repr_table_data_(self) -> ReprTableData:
        return {
            "obj": {f"{idx}": obj for idx, obj in enumerate(self.namelists)},
            "annotations": None,
            "descriptions": None,
        }

    @override
    def _repr_html_(self) -> str:
        repr_ = self.to_string("repr")
        return f"<pre>{repr_}</pre>"

    @override
    def __str__(self) -> str:
        return self.to_string("repr")

    @property
    def by_namelist(self) -> Dict[Type[T_NameList], List[T_NameList]]:
        """Get namelists organized by their class."""
        by_namelist = {}
        for namelist in self.namelists:
            by_namelist.setdefault(type(namelist), [])
            by_namelist[type(namelist)].append(namelist)
        return by_namelist

    @property
    def setup(self) -> Setup:
        """Get the required setup namelist."""
        setups = self.by_namelist.get(Setup, [])
        if len(setups) == 0:
            raise NoSuchNamelistError("Setup is not defined in the input.")
        if len(setups) > 1:
            raise MultipleNamelistsError(
                "Multiple setup namelists were defined in the input."
            )
        return setups[0]

    def to_dicts(
        self,
        exclude_defaults: bool = True,
        by_alias: bool = True,
        **kwargs: Any,
    ) -> List[Dict]:
        """Serialize this main input to a list of dictionaries."""
        return [
            {
                "type": namelist.model_fields["type"].default,
                **namelist.model_dump(
                    exclude_defaults=exclude_defaults, by_alias=by_alias, **kwargs
                ),
            }
            for namelist in self.namelists
        ]

    @classmethod
    def from_dicts(
        cls, contents: Sequence[Dict], filename: Optional[pathlib.Path] = None
    ) -> MainInput:
        """
        Load main input from a list of serialized dictionaries.

        Parameters
        ----------
        contents : sequence of dict
            The serialized contents of the main input file.

        Returns
        -------
        MainInput
        """
        adapter = pydantic.TypeAdapter(AnyNameList)
        return cls(
            namelists=[adapter.validate_python(dct) for dct in contents],
            filename=filename,
        )

    @classmethod
    def from_contents(
        cls, contents: str, filename: Optional[AnyPath] = None
    ) -> MainInput:
        """
        Load main input from its file contents.

        Parameters
        ----------
        contents : str
            The contents of the main input file.
        filename : AnyPath or None, optional
            The filename, if known.

        Returns
        -------
        MainInput
        """
        parser = new_main_input_parser()
        filename = filename or "unknown"
        try:
            tree = parser.parse(contents)
        except Exception:
            if "\n" not in contents:
                raise ValueError(
                    f"Unable to parse the provided input in Genesis4 main input "
                    f"format. It looks like this might have been a filename: "
                    f"{contents!r}"
                )
            raise
        return _MainInputTransformer(filename).transform(tree)

    @classmethod
    def from_file(cls, filename: AnyPath) -> MainInput:
        """
        Load a main input file from disk.

        Parameters
        ----------
        filename : AnyPath
            The filename to load.

        Returns
        -------
        MainInput
        """
        with open(filename) as fp:
            contents = fp.read()
        return cls.from_contents(contents, filename=filename)

    def to_file(
        self,
        filename: AnyPath,
    ) -> None:
        """
        Write the main input file, in Genesis format, to ``filename``.

        Parameters
        ----------
        filename : str or pathlib.Path
        """
        main_config = self.to_genesis()
        with open(filename, "wt") as fp:
            print(main_config, file=fp)

        logger.debug(
            "Wrote main config to %s:\n%s",
            main_config,
            filename,
        )

    def write_files(
        self,
        workdir: AnyPath,
        main_filename: str = "genesis4.in",
        source_path: AnyPath = pathlib.Path(),
        rename: bool = True,
    ) -> List[pathlib.Path]:
        """
        Write the main input file, arrays and other necessary files to run
        Genesis to ``workdir``.

        Parameters
        ----------
        workdir : pathlib.Path or str
            The work directory where Genesis is to be run.
        main_filename : str, default = "genesis4.in"
            Filename to use for the main input file.
        source_path : pathlib.Path or str, optional
            The source directory, where any referenced HDF5 files will be
            found.  Defaults to the current directory.
        rename : bool, optional
            Adjust temporary filenames of HDF5 files, replacing random
            characters with sensible namelist-prefixed names.

        Returns
        -------
        List[pathlib.Path]
            The additional filenames that were written.
        """
        workdir = pathlib.Path(workdir).resolve()
        source_path = pathlib.Path(source_path).resolve()
        if not workdir.exists():
            raise ValueError(f"The configured work directory {workdir} does not exist")
        if not workdir.is_dir():
            raise ValueError(
                f"The configured work directory {workdir} is not a directory"
            )

        # We expect that external files are provided by the user in the
        # same directory as the input files.  Verify they exist first.
        for namelist, filename in self._get_files_to_symlink(workdir):
            source_file = source_path / filename
            if not source_file.exists():
                raise FileNotFoundError(f"{source_file} (referenced in {namelist})")

        paths = []
        # Write out arrays to temporary HDF5 files so the user doesn't have to:
        for cls in (ProfileArray,):
            for idx, namelist in enumerate(self.by_namelist.get(cls, [])):
                if rename or not namelist.filename:
                    namelist.filename = f"{cls.__name__}_{idx}.h5"
                paths.append(namelist.write(workdir))

        # Symlink user-referenced pre-existing HDF5 files:
        for _, filename in self._get_files_to_symlink(workdir):
            source_file = source_path / filename
            symlink = workdir / filename
            _symlink_or_copy(symlink=symlink, file=source_file)

            paths.append(symlink)

        # Write the main input file last, as temporary filenames may have
        # changed above.
        self.to_file(workdir / main_filename)
        paths.append(workdir / main_filename)
        return paths

    def _get_files_to_symlink(
        self, workdir: pathlib.Path
    ) -> Generator[Tuple[AnyNameList, str], None, None]:
        for namelist in self.namelists:
            for attr in ("xdata", "ydata", "file"):
                file = getattr(namelist, attr, None)
                if file is None or isinstance(file, np.ndarray):
                    continue
                file = _split_file(namelist, attr, file)
                if not file:
                    continue

                work_file = workdir / file
                if work_file.exists() and not work_file.is_symlink():
                    # The file was written externally, likely by the
                    # initial_particles handler
                    continue

                yield namelist, file

    def remove(
        self, item_or_class: Union[AnyNameList, Type[NameList], Sequence[AnyNameList]]
    ) -> List[AnyNameList]:
        """
        Remove a item from the namelist by instance or class.

        Parameters
        ----------
        item_or_class : NameList class, instance, or list

        Examples
        --------

        Remove a single instance of "Track" namelists.

        >>> G.input.main.remove(G.input.main.track)

        Remove a single instance of "Track" namelists.

        >>> G.input.main.remove(G.input.main.track)

        Remove all instances of "Track" namelists using the class:

        >>> G.input.main.remove(Track)
        """
        to_remove: List[AnyNameList]
        if isinstance(item_or_class, NameList):
            to_remove = [item_or_class]
        elif isclass(item_or_class):
            to_remove = [
                obj for obj in list(self.namelists) if isinstance(obj, item_or_class)
            ]
        else:
            to_remove = list(item_or_class)

        for obj in to_remove:
            self.namelists.remove(obj)
        return to_remove

    def insert_initial_field(
        self,
        field: FieldFile,
        harmonic: int = 1,
        time: bool = True,
    ) -> int:
        """Insert a FieldFile instance as as an initial field with importfield."""
        to_insert = ImportField(
            file="initial_field.h5",
            harmonic=harmonic,
            time=time,
        )

        try:
            previous = self.import_field
        except NamelistAccessError:
            if self.fields:
                insert_pos = self.namelists.index(self.fields[0])
            elif self.times:
                insert_pos = self.namelists.index(self.times[-1]) + 1
            else:
                logger.warning(
                    "Unable to determine where to insert the importfield; "
                    "placing it after 'setup'"
                )
                insert_pos = self.namelists.index(self.setup)
        else:
            insert_pos = self.namelists.index(previous)
            self.remove(previous)

        self.namelists.insert(insert_pos, to_insert)
        return insert_pos

    def insert_initial_particles(
        self,
        particles: ParticleGroup,
        update_slen: bool,
    ) -> int:
        """Insert a ParticleGroup instance as as an initial particle distribution."""
        to_insert = ImportDistribution(
            file="initial_particles.h5",
            charge=particles.charge,
        )

        try:
            previous = self.import_distribution
        except NamelistAccessError:
            # No previous import_distribution
            if self.tracks:
                insert_pos = self.namelists.index(self.tracks[0])
            elif self.writes:
                insert_pos = self.namelists.index(self.writes[0])
            elif self.times:
                insert_pos = self.namelists.index(self.times[0]) + 1
            else:
                logger.warning(
                    "Unable to determine where to insert the importdistribution; "
                    "placing it at the end"
                )
                insert_pos = len(self.namelists)
        else:
            insert_pos = self.namelists.index(previous)
            self.remove(previous)

        if update_slen:
            for time_ in self.times:
                was = time_.slen
                time_.slen = get_particles_slen(particles)
                if time_.slen != was:
                    logger.warning(
                        "Updating time namelist slen: %f (was %f)",
                        time_.slen,
                        was,
                    )

        self.namelists.insert(insert_pos, to_insert)
        return insert_pos

    @property
    def alter_setups(self) -> List[auto_main.AlterSetup]:
        """List of all AlterSetup instances."""
        return self.by_namelist.get(auto_main.AlterSetup, [])

    @property
    def lattices(self) -> List[auto_main.LatticeNamelist]:
        """List of all Lattice instances."""
        return self.by_namelist.get(auto_main.LatticeNamelist, [])

    @property
    def times(self) -> List[auto_main.Time]:
        """List of all Time instances."""
        return self.by_namelist.get(auto_main.Time, [])

    @property
    def profile_consts(self) -> List[auto_main.ProfileConst]:
        """List of all ProfileConst instances."""
        return self.by_namelist.get(auto_main.ProfileConst, [])

    @property
    def profile_gausses(self) -> List[auto_main.ProfileGauss]:
        """List of all ProfileGauss instances."""
        return self.by_namelist.get(auto_main.ProfileGauss, [])

    @property
    def profile_steps(self) -> List[auto_main.ProfileStep]:
        """List of all ProfileStep instances."""
        return self.by_namelist.get(auto_main.ProfileStep, [])

    @property
    def profile_polynoms(self) -> List[auto_main.ProfilePolynom]:
        """List of all ProfilePolynom instances."""
        return self.by_namelist.get(auto_main.ProfilePolynom, [])

    @property
    def profile_files(self) -> List[auto_main.ProfileFile]:
        """List of all ProfileFile instances."""
        return self.by_namelist.get(auto_main.ProfileFile, [])

    @property
    def sequence_consts(self) -> List[auto_main.SequenceConst]:
        """List of all SequenceConst instances."""
        return self.by_namelist.get(auto_main.SequenceConst, [])

    @property
    def sequence_polynoms(self) -> List[auto_main.SequencePolynom]:
        """List of all SequencePolynom instances."""
        return self.by_namelist.get(auto_main.SequencePolynom, [])

    @property
    def sequence_powers(self) -> List[auto_main.SequencePower]:
        """List of all SequencePower instances."""
        return self.by_namelist.get(auto_main.SequencePower, [])

    @property
    def sequence_randoms(self) -> List[auto_main.SequenceRandom]:
        """List of all SequenceRandom instances."""
        return self.by_namelist.get(auto_main.SequenceRandom, [])

    @property
    def beams(self) -> List[auto_main.Beam]:
        """List of all Beam instances."""
        return self.by_namelist.get(auto_main.Beam, [])

    @property
    def fields(self) -> List[auto_main.Field]:
        """List of all Field instances."""
        return self.by_namelist.get(auto_main.Field, [])

    @property
    def import_distributions(self) -> List[auto_main.ImportDistribution]:
        """List of all ImportDistribution instances."""
        return self.by_namelist.get(auto_main.ImportDistribution, [])

    @property
    def import_beams(self) -> List[auto_main.ImportBeam]:
        """List of all ImportBeam instances."""
        return self.by_namelist.get(auto_main.ImportBeam, [])

    @property
    def import_fields(self) -> List[auto_main.ImportField]:
        """List of all ImportField instances."""
        return self.by_namelist.get(auto_main.ImportField, [])

    @property
    def import_transformations(self) -> List[auto_main.ImportTransformation]:
        """List of all ImportTransformation instances."""
        return self.by_namelist.get(auto_main.ImportTransformation, [])

    @property
    def efields(self) -> List[auto_main.Efield]:
        """List of all Efield instances."""
        return self.by_namelist.get(auto_main.Efield, [])

    @property
    def sponrads(self) -> List[auto_main.Sponrad]:
        """List of all Sponrad instances."""
        return self.by_namelist.get(auto_main.Sponrad, [])

    @property
    def wakes(self) -> List[auto_main.Wake]:
        """List of all Wake instances."""
        return self.by_namelist.get(auto_main.Wake, [])

    @property
    def writes(self) -> List[auto_main.Write]:
        """List of all Write instances."""
        return self.by_namelist.get(auto_main.Write, [])

    @property
    def tracks(self) -> List[auto_main.Track]:
        """List of all Track instances."""
        return self.by_namelist.get(auto_main.Track, [])

    @property
    def alter_fields(self) -> List[auto_main.AlterField]:
        """List of all AlterField instances."""
        return self.by_namelist.get(auto_main.AlterField, [])

    @property
    def profile_file_multis(self) -> List[auto_main.ProfileFileMulti]:
        """List of all ProfileFileMulti instances."""
        return self.by_namelist.get(auto_main.ProfileFileMulti, [])

    @property
    def sequence_lists(self) -> List[auto_main.SequenceList]:
        """List of all SequenceList instances."""
        return self.by_namelist.get(auto_main.SequenceList, [])

    @property
    def sequence_filelists(self) -> List[auto_main.SequenceFilelist]:
        """List of all SequenceFilelist instances."""
        return self.by_namelist.get(auto_main.SequenceFilelist, [])

    @property
    def profile_arrays(self) -> List[ProfileArray]:
        """List of all ProfileArray instances."""
        return self.by_namelist.get(ProfileArray, [])

    def _get_only_one(self, cls: Type[T_NameList]) -> T_NameList:
        items = self.by_namelist.get(cls, [])
        if len(items) == 0:
            raise NoSuchNamelistError(f"{cls.__name__} is not defined in the input.")
        if len(items) > 1:
            plural_fix = {
                "profile_gauss": "profile_gausses",
                "lattice_namelist": "lattices",
            }
            plural = pydantic.alias_generators.to_snake(cls.__name__)
            plural = plural_fix.get(plural, f"{plural}s")
            raise MultipleNamelistsError(
                f"Multiple {cls.__name__} namelists were defined in the input. "
                f"Please use .{plural}"
            )
        return items[0]

    @property
    def alter_setup(self) -> auto_main.AlterSetup:
        """Get a single AlterSetup instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.AlterSetup)

    @property
    def lattice(self) -> auto_main.LatticeNamelist:
        """Get a single Lattice instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.LatticeNamelist)

    @property
    def time(self) -> auto_main.Time:
        """Get a single Time instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Time)

    @property
    def profile_const(self) -> auto_main.ProfileConst:
        """Get a single ProfileConst instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ProfileConst)

    @property
    def profile_gauss(self) -> auto_main.ProfileGauss:
        """Get a single ProfileGauss instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ProfileGauss)

    @property
    def profile_step(self) -> auto_main.ProfileStep:
        """Get a single ProfileStep instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ProfileStep)

    @property
    def profile_polynom(self) -> auto_main.ProfilePolynom:
        """Get a single ProfilePolynom instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ProfilePolynom)

    @property
    def profile_file(self) -> auto_main.ProfileFile:
        """Get a single ProfileFile instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ProfileFile)

    @property
    def sequence_const(self) -> auto_main.SequenceConst:
        """Get a single SequenceConst instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.SequenceConst)

    @property
    def sequence_polynom(self) -> auto_main.SequencePolynom:
        """Get a single SequencePolynom instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.SequencePolynom)

    @property
    def sequence_power(self) -> auto_main.SequencePower:
        """Get a single SequencePower instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.SequencePower)

    @property
    def sequence_random(self) -> auto_main.SequenceRandom:
        """Get a single SequenceRandom instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.SequenceRandom)

    @property
    def beam(self) -> auto_main.Beam:
        """Get a single Beam instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Beam)

    @property
    def field(self) -> auto_main.Field:
        """Get a single Field instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Field)

    @property
    def import_distribution(self) -> auto_main.ImportDistribution:
        """Get a single ImportDistribution instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ImportDistribution)

    @property
    def import_beam(self) -> auto_main.ImportBeam:
        """Get a single ImportBeam instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ImportBeam)

    @property
    def import_field(self) -> auto_main.ImportField:
        """Get a single ImportField instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ImportField)

    @property
    def import_transformation(self) -> auto_main.ImportTransformation:
        """Get a single ImportTransformation instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ImportTransformation)

    @property
    def efield(self) -> auto_main.Efield:
        """Get a single Efield instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Efield)

    @property
    def sponrad(self) -> auto_main.Sponrad:
        """Get a single Sponrad instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Sponrad)

    @property
    def wake(self) -> auto_main.Wake:
        """Get a single Wake instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Wake)

    @property
    def write(self) -> auto_main.Write:
        """Get a single Write instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Write)

    @property
    def track(self) -> auto_main.Track:
        """Get a single Track instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.Track)

    @property
    def alter_field(self) -> auto_main.AlterField:
        """Get a single AlterField instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.AlterField)

    @property
    def profile_file_multi(self) -> auto_main.ProfileFileMulti:
        """Get a single ProfileFileMulti instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.ProfileFileMulti)

    @property
    def sequence_list(self) -> auto_main.SequenceList:
        """Get a single SequenceList instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.SequenceList)

    @property
    def sequence_filelist(self) -> auto_main.SequenceFilelist:
        """Get a single SequenceFilelist instance. Errors if zero or 2+ exist."""
        return self._get_only_one(auto_main.SequenceFilelist)

    @property
    def profile_array(self) -> ProfileArray:
        """Get a single ProfileArray instance. Errors if zero or 2+ exist."""
        return self._get_only_one(ProfileArray)


def _symlink_or_copy(symlink: pathlib.Path, file: pathlib.Path):
    if os.name == "nt":
        # With Windows 10, users need Administator Privileges or run on
        # Developer mode in order to be able to create symlinks.
        # Ref: https://docs.python.org/3/library/os.html#os.symlink
        return shutil.copy2(file, symlink)  # type: ignore[unreachable]

    if symlink != file and not symlink.is_symlink():
        return symlink.symlink_to(file)


def _split_file(namelist: AnyNameList, attr: str, file: str) -> Optional[str]:
    """
    Get a filename from the namelist.

    Namelists such as ProfileFile store arrays in HDF5 files and reference
    them by way of a string in the form: ``"FILENAME/KEY"``.

    This limits Genesis4's ability to load files in absolute paths, as the
    delimiter ``/`` is used to separate the filename from the key.
    """
    if not isinstance(
        namelist,
        (
            ProfileFile,
            ProfileFileMulti,
            ImportDistribution,
            ImportBeam,
            ImportField,
            ImportTransformation,
            SequenceFilelist,
            # ProfileArray,
        ),
    ):
        return None
    if attr in ("xdata", "ydata"):
        # We can't handle paths here, although perhaps lume-genesis
        # could fix this for users... hmm.
        return file.split("/")[0]
    if attr in ("file",):
        return file
    raise NotImplementedError(attr)


class Genesis4Input(BaseModel):
    """
    All Genesis 4-related command input.

    Attributes
    ----------
    main : MainInput
        The main input. This contains all the namelists, starting with
        `&setup`.
    lattice : Lattice
        The lattice definition.
    beamline : str, optional
        Optional override for `beamline` in the setup namelist.
    lattice_name : str, optional
        Optional override for `lattice` in the setup namelist.
    seed : str, optional
        Optional override for `seed` in the setup namelist.
    output_path : Optional[AnyPath] = None
        Optional override for `rootname` in the setup namelist.
    source_path : Optional[AnyPath] = None
        When using Genesis 4-compatible input as strings, this is the directory
        where we expect to find other input HDF5 files.
    input_filename : str = "genesis4.in"
        The filename to use when writing the main input file. As a user, you
        should not need to worry about this as Genesis4Input will handle it for
        you.
    initial_particles : ParticleGroup, optional
        OpenPMD ParticleGroup to use as the initial Genesis 4 particle
        distribution.  If set, this acts as a shortcut for automatically adding
        an ``importdistribution`` namelist and writing the corresponding HDF5
        file for Genesis.
    """

    main: MainInput
    lattice: Lattice
    beamline: Optional[str] = None
    lattice_name: Optional[str] = None
    seed: Optional[str] = None
    source_path: pathlib.Path = pathlib.Path(".")
    output_path: Optional[AnyPath] = None
    input_filename: str = "genesis4.in"
    initial_particles: Optional[PydanticParticleGroup] = None
    initial_field: Optional[FieldFile] = None
    # initial_wavefront: Optional[PmdWavefront] = None

    @pydantic.model_validator(mode="after")
    def _validate_initial_particles(self, info: pydantic.ValidationInfo):
        if self.initial_particles is None:
            if ImportDistribution in self.main.by_namelist:
                logger.warning(
                    "initial_particles cleared; removing ImportDistribution namelist."
                )
                self.main.remove(ImportDistribution)
        else:
            self.main.insert_initial_particles(self.initial_particles, update_slen=True)
        return self

    @pydantic.model_validator(mode="after")
    def _validate_initial_field(self, info: pydantic.ValidationInfo):
        if self.initial_field is None:
            if ImportField in self.main.by_namelist:
                logger.warning("initial_field cleared; removing ImportField namelist.")
                self.main.remove(ImportField)
        else:
            self.main.insert_initial_field(self.initial_field)
        return self

    def to_genesis(self) -> str:
        return "\n".join(
            (
                "# Main input",
                self.main.to_genesis(),
                "",
                "# Lattice",
                self.lattice.to_genesis(),
            )
        )

    @override
    def _repr_html_(self) -> str:
        repr_ = self.to_string("repr")
        return f"<pre>{repr_}</pre>"

    @override
    def __str__(self) -> str:
        return self.to_string("repr")

    @property
    def arguments(self) -> List[str]:
        """
        Get all of the command-line arguments for running Genesis 4.

        Returns
        -------
        list of str
            Individual arguments to pass to Genesis 4.
        """
        optional_args = []
        if self.beamline:
            optional_args.extend(["-b", self.beamline])
        if self.lattice_name:
            optional_args.extend(["-l", self.lattice_name])
        if self.seed is not None:
            optional_args.extend(["-s", self.seed])
        if self.output_path is not None:
            optional_args.extend(["-o", str(self.output_path)])
        return [
            *optional_args,
            "-l",
            str(self.lattice_filename),
            str(self.input_filename),
        ]

    @property
    def lattice_filename(self) -> str:
        """
        The filename of the lattice, determined from the Setup namelist.

        Defaults to "genesis.lat" if not previously set.
        """
        setup = self.main.setup
        if not setup.lattice:
            setup.lattice = "genesis.lat"
        return setup.lattice

    def write(
        self,
        workdir: AnyPath = pathlib.Path("."),
        rename: bool = True,
    ) -> List[pathlib.Path]:
        """
        Write all input files for executing Genesis 4.

        Parameters
        ----------
        workdir : AnyPath
            The working directory for Genesis 4. This will be where all
            input and output files are written.
        rename : bool, optional
            Adjust temporary filenames of HDF5 files, replacing random
            characters with sensible namelist-prefixed names.

        Returns
        -------
        List[pathlib.Path]
            Paths written.
        """
        path = pathlib.Path(workdir)
        path.mkdir(parents=True, mode=0o755, exist_ok=True)

        extra_paths = []
        # Write the particle and field files prior to MainInput, as it will
        # check to ensure that they exist
        if self.initial_particles is not None:
            extra_paths.append(self.write_initial_particles(path))

        if self.initial_field is not None:
            extra_paths.append(self.write_initial_field(path))

        main_paths = self.main.write_files(
            path,
            main_filename=self.input_filename,
            source_path=self.source_path,
            rename=rename,
        )

        extra_paths.extend(main_paths)

        lattice_path = path / self.lattice_filename
        self.lattice.to_file(filename=lattice_path)
        return [path / self.input_filename, lattice_path, *extra_paths]

    def write_initial_field(self, workdir: AnyPath) -> pathlib.Path:
        """Write the initial field file."""
        if self.initial_field is None:
            raise ValueError("initial_field was not set")

        workdir = pathlib.Path(workdir)
        if not workdir.is_dir():
            raise ValueError("Provided path is not a directory: {}")

        import_field = self.main.import_field
        if not import_field.file:
            raise ValueError("import_field filename (.file) unset")

        filename = workdir / import_field.file
        self.initial_field.write_genesis4(filename)
        return filename

    def write_initial_particles(self, workdir: AnyPath) -> pathlib.Path:
        """Write the initial particles file."""
        if self.initial_particles is None:
            raise ValueError("initial_particles was not set")

        workdir = pathlib.Path(workdir)
        if not workdir.is_dir():
            raise ValueError("Provided path is not a directory: {}")

        dist = self.main.import_distribution
        particle_file = pathlib.Path(workdir) / dist.file
        if dist.charge != self.initial_particles.charge:
            logger.warning(
                f"Updating distribution charge: was={dist.charge} "
                f"now={self.initial_particles.charge}"
            )
            dist.charge = self.initial_particles.charge
        for time_ in self.main.times:
            was = time_.slen
            time_.slen = get_particles_slen(self.initial_particles)
            if time_.slen != was:
                logger.warning(
                    f"Updating time namelist slen: was={was} now {time_.slen}",
                )
        self.initial_particles.write_genesis4_distribution(
            str(particle_file),
            verbose=True,
        )
        return particle_file

    def write_run_script(
        self,
        path: pathlib.Path,
        command_prefix: str = "genesis4",
    ) -> None:
        with open(path, mode="wt") as fp:
            print(shlex.join(shlex.split(command_prefix) + self.arguments), file=fp)
        lume_tools.make_executable(str(path))

    @contextmanager
    def write_context(
        self, workdir: AnyPath
    ) -> Generator[List[pathlib.Path], None, None]:
        """
        Write all input files for executing Genesis 4.

        This is a context manager. When the context manager exits, all input
        files will be cleaned up (i.e., deleted from disk).

        Parameters
        ----------
        workdir : AnyPath
            The working directory for Genesis 4. This will be where all
            input and output files are written.

        Yields
        ------
        List[pathlib.Path]
            Paths written.
        """
        paths = self.write(workdir)
        yield paths
        for path in paths:
            path.unlink(missing_ok=True)

    @classmethod
    def from_main_input(
        cls,
        main: MainInput,
        lattice: Union[Lattice, str, pathlib.Path] = "",
        *,
        source_path: Optional[pathlib.Path] = None,
    ) -> Genesis4Input:
        """
        Work with a lume-genesis MainInput and potentially an external
        lattice file or instance.

        If the input refers to files that already exist on disk, ensures
        that `source_path` is set correctly.
        """
        if source_path is None:
            source_path = pathlib.Path(".")

        if isinstance(lattice, Lattice):
            return cls(
                main=main,
                lattice=lattice,
                source_path=source_path,
            )

        if lattice:
            lattice_path, lattice = tools.read_if_path(lattice)
            if lattice_path is not None:
                try:
                    setup = main.setup
                except NoSuchNamelistError:
                    # No setup yet; skip for now
                    pass
                else:
                    main.setup.lattice = lattice_path.name
            lattice = Lattice.from_contents(lattice, filename=lattice_path)
        else:
            logger.debug("Lattice not specified; determining from main input")
            setup = None
            try:
                setup = main.setup
                assert setup is not None
                # Use the lattice filename from main input's setup:
                with open(source_path / setup.lattice) as fp:
                    lattice = fp.read()
            except Exception:
                if setup is not None:
                    logger.exception(
                        (
                            "Lattice not specified and unable to determine it from the "
                            "main input's setup. Setup.lattice=%s Lattice file should "
                            "be located here: %s"
                        ),
                        setup.lattice,
                        source_path / setup.lattice,
                    )
                raise
            lattice = Lattice.from_contents(
                lattice, filename=source_path / setup.lattice
            )

        return cls(
            main=main,
            lattice=lattice,
            source_path=source_path,
        )

    @classmethod
    def from_strings(
        cls,
        main: str,
        lattice: str = "",
        *,
        source_path: pathlib.Path = pathlib.Path("."),
        input_filename: Optional[pathlib.Path] = None,
        lattice_filename: Optional[pathlib.Path] = None,
    ) -> Genesis4Input:
        """
        Work directly with Genesis 4-compatible inputs.

        If unspecified, `lattice` will be determined from the `main` input
        settings.

        If the input refers to files that already exist on disk, ensures
        that `source_path` is set correctly.
        """
        main_config = MainInput.from_contents(main, filename=input_filename)

        if not lattice:
            return cls.from_main_input(main_config, source_path=source_path)

        return cls(
            main=main_config,
            lattice=Lattice.from_contents(lattice, filename=lattice_filename),
            source_path=source_path,
        )

    def archive(self, h5: h5py.Group) -> None:
        """
        Dump input data into the given HDF5 group.

        Parameters
        ----------
        h5 : h5py.Group
            The HDF5 file in which to write the information.
        """
        _archive.store_in_hdf5_file(h5, self)

    @classmethod
    def from_archive(cls, h5: h5py.Group) -> Genesis4Input:
        """
        Loads input from archived h5 file.

        Parameters
        ----------
        h5 : str or h5py.File
            The filename or handle on h5py.File from which to load data.
        """
        loaded = _archive.restore_from_hdf5_file(h5)
        if not isinstance(loaded, Genesis4Input):
            raise ValueError(
                f"Loaded {loaded.__class__.__name__} instead of a "
                f"Genesis4Input instance.  Was the HDF group correct?"
            )
        return loaded


def new_parser(filename: AnyPath, **kwargs: Any) -> lark.Lark:
    """
    Get a new parser for one of the packaged grammars.

    Parameters
    ----------
    filename : str
        The packaged grammar filename.
    **kwargs :
        See :class:`lark.lark.LarkOptions`.
    """
    return lark.Lark.open_from_package(
        "genesis",
        str(filename),
        parser="lalr",
        maybe_placeholders=True,
        propagate_positions=True,
        **kwargs,
    )


def new_lattice_parser(**kwargs: Any) -> lark.Lark:
    """
    Get a new parser for the packaged Lattice input grammar.

    Parameters
    ----------
    **kwargs :
        See :class:`lark.lark.LarkOptions`.
    """
    return new_parser(LATTICE_GRAMMAR, **kwargs)


def new_main_input_parser(**kwargs: Any) -> lark.Lark:
    """
    Get a new parser for the packaged main input file grammar.

    Parameters
    ----------
    **kwargs :
        See :class:`lark.lark.LarkOptions`.
    """
    return new_parser(MAIN_INPUT_GRAMMAR, **kwargs)


def check_allows_reference(field: pydantic.fields.FieldInfo) -> bool:
    """Check if a field allows for a Reference type."""
    # A lazy method rather than full inspection of the annotated type. This
    # should work well enough assuming our type hints don't become extremely
    # complicated.
    return "Reference" in str(field.annotation)


def get_primary_type(field: pydantic.fields.FieldInfo) -> type:
    def is_model(typ: object):
        return isclass(typ) and issubclass(typ, pydantic.BaseModel)

    def check_type(typ: type) -> type:
        if is_model(typ):
            return typ
        if typ in {float, int, bool, str}:
            return typ
        if typing.get_origin(typ) in union_types:
            for subtype in typing.get_args(typ):
                if is_model(subtype):
                    if subtype is Reference:
                        continue
                    return subtype
                # TODO: throwing away anything beyond a union of 2
                return check_type(subtype)
        raise TypeError(f"Unhandled type: {typ}")

    assert field.annotation is not None
    return check_type(field.annotation)


def _fix_parameters(
    cls: Union[Type[BeamlineElement], Type[NameList]],
    params: Dict[str, lark.Token],
) -> Tuple[Dict[str, ValueType], Dict[str, str]]:
    """
    Fix parameters to beamline elements when transforming with
    :class:``_LatticeTransformer`.

    Parameters
    ----------
    cls : Type[BeamlineElement]
        The dataclass associated with the beamline element.  This is used to
        determine the attribute name and data type associated with the
        parameter.
    params : Dict[str, lark.Token]
        Parameter name map to lark Token value.

    Returns
    -------
    Dict[str, ValueType]
        Arguments for Pydantic model validation.
    Dict[str, str]
        Unexpected arguments for the dataclass; unsure what to do with them.
    """
    kwargs: Dict[str, ValueType] = {}
    extra: Dict[str, str] = {}
    fields = {
        field.serialization_alias: field
        for field in cls.model_fields.values()
        if field.serialization_alias
    }
    fields.update(
        {field.alias: field for field in cls.model_fields.values() if field.alias}
    )
    fields.update(cls.model_fields)

    for name, value in params.items():
        field = fields[name]
        dtype = field.annotation
        allow_reference = check_allows_reference(field)
        dtype = get_primary_type(field)
        string_value = str(value).strip()
        if value.startswith("@") and allow_reference:
            kwargs[name] = Reference(string_value[1:].strip())
        elif dtype is int:
            try:
                kwargs[name] = int(value)
            except ValueError:
                # These may be references, let pydantic deal with them
                kwargs[name] = value
        elif dtype is float:
            try:
                kwargs[name] = float(value.rstrip("."))
            except ValueError:
                # These may be references, let pydantic deal with them
                kwargs[name] = value
        elif dtype is bool:
            kwargs[name] = string_value.lower() in ("true", "t", "1")
        elif dtype is str:
            kwargs[name] = string_value
        else:
            raise RuntimeError(f"Unexpected type annotation hit for {name}: {dtype}")
    return kwargs, extra


class _LatticeTransformer(lark.visitors.Transformer_InPlaceRecursive):
    """
    Grammar transformer which takes lark objects and makes a :class:`Lattice`.

    Attributes
    ----------
    _filename : str
        Filename source of the input.
    """

    _filename: Optional[pathlib.Path]

    def __init__(self, filename: AnyPath) -> None:
        super().__init__()
        self._filename = pathlib.Path(filename)

        # This maps, e.g., "setup" to the Setup dataclass
        self.type_name_to_class: Dict[str, Type[BeamlineElement]] = {
            cls.model_fields["type"].default: cls
            for cls in BeamlineElement.__subclasses__()
        }
        # Per the Genesis documents, only the first 4 characters are compared:
        self.partial_type_name_to_class = {
            name[:4].upper(): cls for name, cls in self.type_name_to_class.items()
        }

    @lark.v_args(inline=True)
    def line(
        self,
        label: lark.Token,
        _: lark.Token,  # line
        element_list: List[LineItem],
    ) -> Tuple[str, Line]:
        return str(label), Line(elements=element_list)

    @lark.v_args(inline=True)
    def parameter_set(
        self,
        parameter: lark.Token,
        value: lark.Token,
    ) -> Tuple[str, lark.Token]:
        return str(parameter), value

    def parameter_list(
        self, sets: List[Tuple[str, ValueType]]
    ) -> List[Tuple[str, ValueType]]:
        return list(sets)

    @lark.v_args(inline=True)
    def beamline_element(
        self,
        label: lark.Token,
        type_: lark.Token,
        parameter_list: Optional[List[Tuple[str, lark.Token]]],
    ) -> Tuple[str, BeamlineElement]:
        cls = self.partial_type_name_to_class[type_.upper()[:4]]
        parameters, unknown = _fix_parameters(cls, dict(parameter_list or []))
        if unknown:
            raise ValueError(
                f"Beamline element {label} received unexpected parameter(s): "
                f"{unknown}"
            )
        parameters["type"] = cls.model_fields["type"].default.lower()
        element = cls.model_validate(parameters)
        return str(label), element

    @lark.v_args(inline=True)
    def duplicate_item(
        self,
        count: lark.Token,
        label: lark.Token,
    ) -> DuplicatedLineItem:
        return DuplicatedLineItem(
            label=str(label),
            count=int(count),
        )

    @lark.v_args(inline=True)
    def positioned_item(
        self,
        label: lark.Token,
        position: lark.Token,
    ) -> PositionedLineItem:
        return PositionedLineItem(
            label=str(label),
            position=float(position),
        )

    @lark.v_args(inline=True)
    def line_item(
        self, item: Union[lark.Token, DuplicatedLineItem, PositionedLineItem]
    ) -> Union[str, DuplicatedLineItem, PositionedLineItem]:
        if isinstance(item, lark.Token):
            return str(item)
        return item

    def element_list(
        self, items: List[Union[lark.Token, DuplicatedLineItem, PositionedLineItem]]
    ) -> List[Union[lark.Token, DuplicatedLineItem, PositionedLineItem]]:
        return items

    def lattice(self, elements: List[Tuple[str, AnyBeamlineElement]]) -> Lattice:
        return Lattice(
            elements=dict(elements),
            filename=self._filename,
        )


class _MainInputTransformer(lark.visitors.Transformer_InPlaceRecursive):
    """
    Grammar transformer which takes lark objects and makes a :class:`MainInput`.

    Attributes
    ----------
    _filename : str
        Filename source of the input.
    """

    _filename: Optional[pathlib.Path]

    def __init__(self, filename: AnyPath) -> None:
        super().__init__()
        self._filename = pathlib.Path(filename)

        # This maps, e.g., "setup" to the Setup dataclass
        self.type_name_to_class = {
            cls.model_fields["type"].default: cls for cls in NameList.__subclasses__()
        }

    @lark.v_args(inline=True)
    def parameter_set(
        self,
        parameter: lark.Token,
        value: lark.Token,
    ) -> Tuple[str, lark.Token]:
        return (str(parameter), value)

    def parameter_list(
        self, sets: List[Tuple[str, ValueType]]
    ) -> List[Tuple[str, ValueType]]:
        return list(sets)

    @lark.v_args(inline=True)
    def namelist(
        self,
        name: lark.Token,
        parameter_list: List[Tuple[str, lark.Token]],
        _: lark.Token,  # end
    ) -> NameList:
        cls = self.type_name_to_class[name]
        parameters, unknown = _fix_parameters(cls, dict(parameter_list))
        if unknown:
            raise ValueError(
                f"Namelist {name} received unexpected parameter(s): {unknown}"
            )
        return cls(**parameters)

    @lark.v_args(inline=True)
    def main_input(self, *namelists: AnyNameList) -> MainInput:
        return MainInput(namelists=list(namelists), filename=self._filename)
