#!/usr/bin/env python
# vi: syntax=python sw=4 ts=4 sts=4
"""
This file is auto-generated by lume-genesis (`genesis.version4.input.manual`).

Do not hand-edit it.
"""
from __future__ import annotations
import abc
import typing

import pydantic

from typing import Dict, Literal, Union
from . import util
from ..types import SerializedReference, ValueType, TaggedUnion

{% if base_class == "NameList" %}
class Reference(pydantic.BaseModel):
    """
    A Genesis 4 main input value which is a reference to another namelist or
    value.

    Attributes
    ----------
    label : str
        The reference name.
    """

    label: str

    def serialize(self) -> str:
        return str(self)

    def __str__(self) -> str:
        return f"@{self.label}"

    @classmethod
    def from_namelist(cls, value: Union[Reference, SerializedReference, str]) -> Reference:
        if isinstance(value, Reference):
            return value
        if isinstance(value, str) and value.startswith("@"):
            return cls(label=value.lstrip("@ "))
        if isinstance(value, dict):
            return cls(**value)
        raise ValueError(f"Unexpected type for a Reference in a NameList: {value}")


class NameList(pydantic.BaseModel, abc.ABC):
    """Base class for name lists used in Genesis 4 main input files."""

    def __post_model_init__(self) -> None:
        # Fix up any references or types for convenience (and deserialization)
        # TODO/NOTE: anything more complicated than this will call for
        # msgspec / apischema / pydantic for (de)serialization
        for attr, annotation in self.__annotations__.items():
            if attr.startswith("_"):
                pass
            elif "Reference" in annotation:
                try:
                    value = Reference.from_namelist(getattr(self, attr))
                except ValueError:
                    # Not a reference type to be deserialized
                    ...
                else:
                    # Update the attribute with the Reference instance.
                    setattr(self, attr, value)

    @property
    def genesis_parameters(self) -> Dict[str, ValueType]:
        """Dictionary of parameters to pass to Genesis 4."""
        return {
            attr: value
            for attr, value in util.get_non_default_attrs(self).items()
            if attr not in {"type"}
        }

    def to_genesis(self) -> str:
        """Create a Genesis 4-compatible namelist from this instance."""
        parameters = (
            f"  {name} = {util.python_to_namelist_value(value)}"
            for name, value in self.genesis_parameters.items()
        )
        return "\n".join(
            (
                f"&{self.type}",
                *parameters,
                "&end",
            )
        )

    def __str__(self) -> str:
        return self.to_genesis()

    def __repr__(self) -> str:
        return util.get_non_default_repr(self)
{%- elif base_class == "BeamlineElement" %}
class BeamlineElement(pydantic.BaseModel, abc.ABC):
    """Base class for beamline elements used in Genesis 4 lattice files."""
    label: str

    @property
    def genesis_parameters(self) -> Dict[str, ValueType]:
        """Dictionary of parameters to pass to Genesis 4."""
        return {
            attr: value
            for attr, value in util.get_non_default_attrs(self).items()
            if attr not in {"type"}
        }

    def to_genesis(self) -> str:
        """Create a Genesis 4 compatible element from this instance."""
        parameters = ", ".join(
            f"{name}={util.python_to_namelist_value(value)}"
            for name, value in self.genesis_parameters.items()
            if name not in {"label"}
        )
        return "".join(
            (
                self.label,
                f": {self.type} = ",
                "{",
                parameters,
                "};",
            )
        )

    def __str__(self) -> str:
        return self.to_genesis()

    def __repr__(self) -> str:
        return util.get_non_default_repr(self)
{%- endif %}
{%- for name, element in manual.elements.items() %}
{%- if element.parameters | length %}

{% macro field_value(param) -%}
    {%- if "vector" in param.options -%}
        {{ " = " -}}
        pydantic.Field(default_factory=list
            {%- if param.name != param.python_name -%}, serialization_alias="{{ param.name }}"
            {%- endif -%}
        )
    {%- elif param.default is none -%}
        {%- if param.python_name != param.name -%}
            {{ " = " }}pydantic.Field(serialization_alias="{{ param.name }}")
        {%- endif -%}
    {%- else -%}
        {%- if param.python_name != param.name -%}
            {{ " = " }}pydantic.Field(serialization_alias="{{ param.name }}", default={{ param.default | repr }})
        {%- else -%}
            {{ " = " }}{{ param.default | repr }}
        {%- endif -%}
    {%- endif -%}
{%- endmacro%}
class {{ name | to_class_name }}({{ base_class }}):
    r"""
    {%- if element.header %}
    {{ element.header | wordwrap | indent(4) }}
    {%- elif name in docstrings %}
    {{ docstrings[name] | wordwrap | indent(4) }}
    {%- endif %}

    {{ name | to_class_name }} corresponds to Genesis 4 `{{ name }}`.

    Attributes
    ----------
    {%- for param in element.parameters.values() %}
    {%- set type_ = type_map.get(param.type, param.type) %}
    {{ param.python_name }} : {{ type_ }}{% if not param.default is none %}, default={{ param.default | repr }}{% endif %}
        {{ param.description | wordwrap | indent(8) }}
    {%- endfor %}
    """

    type: Literal["{{ name }}"] = "{{ name }}"
    {%- for param in element.parameters.values() %}
    {%- set type_ = type_map.get(param.type, param.type) %}
    {%- if "reference" in param.options %}
    {%- set ref_suffix = " | Reference" %}
    {%- else %}
    {%- set ref_suffix = "" %}
    {%- endif %}
    {%- if "vector" in param.options %}
    {{ param.python_name }}: typing.Sequence[{{ type_ }}]{{ ref_suffix }}{{ field_value(param) }}
    {%- else %}
    {{ param.python_name }}: {{ type_ }}{{ ref_suffix}}{{ field_value(param) }}
    {%- endif %}
    {%- endfor %}
    {%- if base_class == "BeamlineElement" %}
    label: str = ""
    {%- endif %}
{%- endif %}
{%- endfor %}

Autogenerated{{ base_class }} = Union[
{%- for name, element in manual.elements.items() %}
{%- if element.parameters | length %}
    {{ name | to_class_name }},
{%- endif %}
{%- endfor %}
]
