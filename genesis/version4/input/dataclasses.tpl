#!/usr/bin/env python
# vi: syntax=python sw=4 ts=4 sts=4
"""
This file is auto-generated by lume-genesis (`genesis.version4.input.manual`).

Do not hand-edit it.
"""
from __future__ import annotations
import dataclasses
import typing

from typing import Dict

from . import util
from .types import Float, SerializedReference, ValueType

{% if base_class == "NameList" %}
@dataclasses.dataclass
class Reference:
    """
    A Genesis 4 main input value which is a reference to another namelist or
    value.

    Attributes
    ----------
    label : str
        The reference name.
    """

    label: str

    def serialize(self) -> str:
        return str(self)

    def __str__(self) -> str:
        return f"@{self.label}"

    @classmethod
    def from_namelist(cls, value: typing.Union[Reference, SerializedReference, str]) -> Reference:
        if isinstance(value, Reference):
            return value
        if isinstance(value, str) and value.startswith("@"):
            return cls(label=value.lstrip("@ "))
        if isinstance(value, dict):
            return cls(**value)
        raise ValueError(f"Unexpected type for a Reference in a NameList: {value}")


@dataclasses.dataclass(repr=False)
class NameList:
    """Base class for name lists used in Genesis 4 main input files."""
    _genesis_name_: typing.ClassVar[str] = "unknown"
    _parameter_to_attr_: typing.ClassVar[Dict[str, str]] = util.renames
    _attr_to_parameter_: typing.ClassVar[Dict[str, str]] = dict(
        (v, k) for k, v in _parameter_to_attr_.items()
    )

    def __post_init__(self) -> None:
        # Fix up any references or types for convenience (and deserialization)
        # TODO/NOTE: anything more complicated than this will call for
        # msgspec / apischema / pydantic for (de)serialization
        for attr, annotation in self.__annotations__.items():
            if attr.startswith("_"):
                pass
            elif "Reference" in annotation:
                try:
                    value = Reference.from_namelist(getattr(self, attr))
                except ValueError:
                    # Not a reference type to be deserialized
                    ...
                else:
                    # Update the attribute with the Reference instance.
                    setattr(self, attr, value)

    def to_dict(self) -> Dict:
        """
        Get a serialized (dictionary representation) of this namelist.
        """
        data = dataclasses.asdict(self)
        return {
            "type": self._genesis_name_,
            **data,
        }

    @classmethod
    def from_dict(cls, dct: Dict) -> NameList:
        """
        Deserialize a dictionary into a NameList instance.

        Parameters
        ----------
        dct : dict
            Dictionary of parameters, where "type" is a required key.

        Returns
        -------
        NameList
            A specific subclass instance, such as a :class:`Setup`.
        """
        type_ = dct.get("type", None)
        if type_ is None:
            raise ValueError(
                "The input dictionary does not contain a 'type'"
            )
        for cls in cls.__subclasses__():
            if cls._genesis_name_ == type_:
                params = dict(dct)
                params.pop("type")
                return cls(**params)

        raise ValueError(f"Unsupported namelist type: {type_!r}")

    @property
    def genesis_parameters(self) -> Dict[str, ValueType]:
        """Dictionary of parameters to pass to Genesis 4."""
        return {
            self._attr_to_parameter_.get(attr, attr): value
            for attr, value in util.get_non_default_attrs(self).items()
        }

    def to_genesis(self) -> str:
        """Create a Genesis 4-compatible namelist from this instance."""
        parameters = (
            f"  {name} = {util.python_to_namelist_value(value)}"
            for name, value in self.genesis_parameters.items()
        )
        return "\n".join(
            (
                f"&{self._genesis_name_}",
                *parameters,
                "&end",
            )
        )

    def __str__(self) -> str:
        return self.to_genesis()

    def __repr__(self) -> str:
        return util.get_non_default_repr(self)
{%- elif base_class == "BeamlineElement" %}
@dataclasses.dataclass(repr=False)
class BeamlineElement:
    """Base class for beamline elements used in Genesis 4 lattice files."""
    _genesis_name_: typing.ClassVar[str] = "unknown"
    _parameter_to_attr_: typing.ClassVar[Dict[str, str]] = util.renames
    _attr_to_parameter_: typing.ClassVar[Dict[str, str]] = dict(
        (v, k) for k, v in _parameter_to_attr_.items()
    )

    def to_dict(self) -> Dict:
        """
        Get a serialized (dictionary representation) of this beamline element.
        """
        return {
            "type": self._genesis_name_,
            **dataclasses.asdict(self)
        }

    @classmethod
    def from_dict(cls, dct: Dict) -> BeamlineElement:
        """
        Deserialize a dictionary into a BeamlineElement instance.

        Parameters
        ----------
        dct : dict
            Dictionary of parameters, where "type" is a required key.

        Returns
        -------
        BeamlineElement
            A specific subclass instance, such as a :class:`Undulator`.
        """
        type_ = dct.get("type", None)
        if type_ is None:
            raise ValueError(
                "The input dictionary does not contain a 'type'"
            )
        for cls in cls.__subclasses__():
            if cls._genesis_name_ == type_:
                params = dict(dct)
                params.pop("type")
                return cls(**params)

        raise ValueError(f"Unsupported namelist type: {type_!r}")

    @property
    def genesis_parameters(self) -> Dict[str, ValueType]:
        """Dictionary of parameters to pass to Genesis 4."""
        return {
            self._attr_to_parameter_.get(attr, attr): value
            for attr, value in util.get_non_default_attrs(self).items()
        }

    def to_genesis(self) -> str:
        """Create a Genesis 4 compatible element from this instance."""
        parameters = ", ".join(
            f"{name}={util.python_to_namelist_value(value)}"
            for name, value in self.genesis_parameters.items()
            if name not in {"label"}
        )
        return "".join(
            (
                self.label,
                f": {self._genesis_name_} = ",
                "{",
                parameters,
                "};",
            )
        )

    def __str__(self) -> str:
        return self.to_genesis()

    def __repr__(self) -> str:
        return util.get_non_default_repr(self)

    @property
    def label(self) -> str:
        # Note: see subclass 'label' attribute. It's used with the dataclass.
        raise NotImplementedError("Internal error; subclass should add 'label'")

    @label.setter
    def label(self, value: str) -> None:
        raise NotImplementedError("Internal error; subclass should add 'label'")
{%- endif %}
{%- for name, element in manual.elements.items() %}
{%- if element.parameters | length %}


@dataclasses.dataclass(repr=False)
class {{ name | to_class_name }}({{ base_class }}):
    r"""
    {%- if element.header %}
    {{ element.header | wordwrap | indent(4) }}
    {%- elif name in docstrings %}
    {{ docstrings[name] | wordwrap | indent(4) }}
    {%- endif %}

    {{ name | to_class_name }} corresponds to Genesis 4 `{{ name }}`.

    Attributes
    ----------
    {%- for param in element.parameters.values() %}
    {%- set type_ = type_map.get(param.type, param.type) %}
    {{ param.python_name }} : {{ type_ }}{% if not param.default is none %}, default={{ param.default | repr }}{% endif %}
        {{ param.description | wordwrap | indent(8) }}
    {%- endfor %}
    """
    _genesis_name_: typing.ClassVar[str] = "{{ name }}"

    {%- for param in element.parameters.values() %}
    {%- set type_ = type_map.get(param.type, param.type) %}
    {%- if "reference" in param.options %}
    {%- set ref_suffix = " | Reference" %}
    {%- else %}
    {%- set ref_suffix = "" %}
    {%- endif %}
    {%- if "vector" in param.options %}
    {{ param.python_name }}: typing.Sequence[{{ type_ }}]{{ ref_suffix}} = dataclasses.field(default_factory=list)
    {%- else %}
    {{ param.python_name }}: {{ type_ }}{{ ref_suffix}} {%- if not param.default is none %} = {{ param.default | repr }}{% endif %}
    {%- endif %}
    {%- endfor %}
    {%- if base_class == "BeamlineElement" %}
    label: str = ""
    {%- endif %}
{%- endif %}
{%- endfor %}
